<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Ng∆∞·ªùi C·∫ßm Quy·ªÅn Simulator - With Difficulty Modes - v2.1</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-color: #6366f1;
        --secondary-color: #8b5cf6;
        --accent-color: #06d6a0;
        --danger-color: #ef4444;
        --warning-color: #f59e0b;
        --success-color: #10b981;
        --background-dark: #0f0f23;
        --background-secondary: #1a1a3a;
        --background-light: #2a2a4a;
        --text-primary: #f8fafc;
        --text-secondary: #cbd5e1;
        --text-muted: #94a3b8;
        --border-color: #334155;
        --shadow-color: rgba(99, 102, 241, 0.2);
        --glow-color: rgba(99, 102, 241, 0.4);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        width: 100%;
        overflow-x: hidden;
      }

      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        font-family: "Inter", sans-serif;
        background: radial-gradient(ellipse at top, var(--background-secondary) 0%, var(--background-dark) 70%);
        color: var(--text-primary);
        overflow-x: hidden;
        position: relative;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 20% 50%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 80%, rgba(6, 214, 160, 0.05) 0%, transparent 50%);
        pointer-events: none;
        z-index: -1;
      }

      /* Difficulty Selection Screen */
      .difficulty-selection {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(26, 26, 58, 0.95) 100%);
        backdrop-filter: blur(20px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .difficulty-modal {
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        padding: 40px;
        border-radius: 24px;
        max-width: 700px;
        width: 90%;
        text-align: center;
        border: 1px solid var(--border-color);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), 0 0 0 1px var(--shadow-color);
        position: relative;
        overflow: hidden;
        margin: 20px;
      }

      .difficulty-modal::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      }

      .difficulty-option {
        margin: 20px 0;
        padding: 30px;
        border: 2px solid var(--border-color);
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
        position: relative;
        overflow: hidden;
      }

      .difficulty-option::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.5s ease;
      }

      .difficulty-option:hover::before {
        left: 100%;
      }

      .difficulty-option:hover {
        border-color: var(--primary-color);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
        transform: translateY(-5px) scale(1.02);
        box-shadow: 0 20px 40px rgba(99, 102, 241, 0.2);
      }

      .difficulty-option h3 {
        margin: 0 0 15px 0;
        color: var(--text-primary);
        font-size: 1.5em;
        font-weight: 600;
        font-family: "Poppins", sans-serif;
        letter-spacing: -0.02em;
      }

      .difficulty-option p {
        margin: 0 0 15px 0;
        color: var(--text-secondary);
        font-size: 1.1em;
        line-height: 1.5;
      }

      .difficulty-stats {
        font-size: 0.95em;
        color: var(--text-muted);
        margin-top: 15px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      #difficulty-indicator {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 15px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 500;
        border: 1px solid #444;
      }

      /* Start Screen */
      .start-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--background-dark);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        text-align: center;
        transition: opacity 0.8s ease;
        overflow: hidden;
        padding: 20px;
        box-sizing: border-box;
      }

      .start-screen::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 30% 30%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 70% 70%, rgba(139, 92, 246, 0.15) 0%, transparent 50%);
        animation: pulse 4s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
      }

      .start-screen.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .start-title {
        font-family: "Poppins", sans-serif;
        font-size: 4em;
        font-weight: 800;
        color: var(--text-primary);
        text-align: center;
        margin-bottom: 20px;
        text-shadow: 0 0 20px var(--glow-color);
        letter-spacing: -0.02em;
        position: relative;
        z-index: 1;
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: titleGlow 3s ease-in-out infinite;
      }

      @keyframes titleGlow {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.2);
        }
      }

      .start-subtitle {
        font-size: 1.4em;
        color: var(--text-secondary);
        text-align: center;
        margin-bottom: 50px;
        font-weight: 300;
        position: relative;
        z-index: 1;
      }

      .start-btn {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
        border: none;
        padding: 18px 50px;
        font-size: 1.2em;
        font-weight: 600;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 10px 30px var(--shadow-color);
        position: relative;
        z-index: 1;
        font-family: "Poppins", sans-serif;
        overflow: hidden;
      }

      .start-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
      }

      .start-btn:hover::before {
        left: 100%;
      }

      .start-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 20px 50px var(--shadow-color);
      }

      /* Guide Button */
      .guide-btn {
        position: fixed;
        top: 30px;
        right: 30px;
        background: linear-gradient(135deg, var(--background-light), var(--background-secondary));
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 12px 24px;
        font-size: 0.9em;
        font-weight: 500;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 999;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: none;
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .guide-btn:hover {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        border-color: var(--primary-color);
        color: white;
        transform: translateY(-3px);
        box-shadow: 0 8px 25px var(--shadow-color);
      }

      /* Guide Modal */
      .guide-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 2000;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .guide-content {
        background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        padding: 30px;
        border-radius: 20px;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        border: 2px solid #444;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
      }

      .guide-title {
        font-size: 2rem;
        color: #fff;
        text-align: center;
        margin-bottom: 20px;
      }

      .guide-section {
        margin-bottom: 25px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      .guide-section h3 {
        color: #4caf50;
        font-size: 1.3em;
        margin-bottom: 15px;
      }

      .guide-section h4 {
        color: #ffd700;
        font-size: 1.1em;
        margin: 15px 0 10px 0;
      }

      .guide-section p,
      .guide-section li {
        color: #ccc;
        line-height: 1.6;
        margin-bottom: 8px;
      }

      .guide-section ul {
        margin-left: 20px;
      }

      .ending-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid;
      }

      .ending-success {
        border-left-color: #4caf50;
      }
      .ending-failure {
        border-left-color: #f44336;
      }
      .ending-special {
        border-left-color: #ff9800;
      }

      .close-guide {
        background: #f44336;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
        margin-top: 20px;
        float: right;
      }

      .close-guide:hover {
        background: #d32f2f;
      }

      /* Main Container */
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 30px;
        position: relative;
        width: 100%;
        box-sizing: border-box;
      }

      /* Game Layout - 2 Columns */
      .game-layout {
        display: grid;
        grid-template-columns: 350px 1fr;
        gap: 30px;
        align-items: start;
      }

      .left-panel {
        position: sticky;
        top: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
        padding: 20px;
        border-radius: 20px;
        border: 1px solid rgba(99, 102, 241, 0.2);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(99, 102, 241, 0.1);
      }

      .right-panel {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 30px;
        background: linear-gradient(135deg, rgba(6, 214, 160, 0.03) 0%, rgba(99, 102, 241, 0.03) 100%);
        padding: 20px;
        border-radius: 20px;
        border: 1px solid rgba(6, 214, 160, 0.1);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(6, 214, 160, 0.05);
      }

      /* Panel Titles */
      .panel-title {
        font-family: "Poppins", sans-serif;
        font-size: 1.1em;
        font-weight: 600;
        color: var(--primary-color);
        text-align: center;
        padding: 15px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
        border-radius: 12px;
        border: 1px solid rgba(99, 102, 241, 0.3);
        margin-bottom: 10px;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

      /* Alert Messages */
      .crisis-alert {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, var(--danger-color), #dc2626);
        color: white;
        padding: 15px 30px;
        border-radius: 50px;
        font-weight: 700;
        font-size: 1.1em;
        z-index: 2000;
        animation: alertSlide 0.5s ease-out, alertPulse 2s infinite 0.5s;
        box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4);
        display: none;
      }

      @keyframes alertSlide {
        from {
          top: -50px;
          opacity: 0;
        }
        to {
          top: 80px;
          opacity: 1;
        }
      }

      @keyframes alertPulse {
        0%,
        100% {
          transform: translateX(-50%) scale(1);
        }
        50% {
          transform: translateX(-50%) scale(1.05);
        }
      }

      /* Header */
      .header {
        text-align: center;
        margin-bottom: 40px;
        position: relative;
        width: 100%;
      }

      .header h1 {
        font-family: "Poppins", sans-serif;
        font-size: 3.2em;
        margin: 0 0 15px 0;
        font-weight: 700;
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px var(--glow-color);
        letter-spacing: -0.02em;
        line-height: 1.1;
      }

      .header .subtitle {
        font-size: 1.3em;
        color: var(--text-secondary);
        font-weight: 300;
        margin-bottom: 20px;
      }

      .header::after {
        content: "";
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        width: 100px;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      }

      /* Stats Panel */
      .stats-panel {
        display: grid;
        grid-template-columns: 1fr;
        gap: 15px;
        margin-bottom: 0;
        padding: 25px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
        border-radius: 20px;
        backdrop-filter: blur(20px);
        border: 1px solid var(--border-color);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        width: 100%;
        box-sizing: border-box;
      }

      .stat {
        text-align: center;
        padding: 25px 20px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
        border-radius: 16px;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
      }

      .stat::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .stat:hover::before {
        opacity: 1;
      }

      .stat:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 15px 40px rgba(99, 102, 241, 0.2);
        border-color: var(--primary-color);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      }

      .stat-label {
        font-size: 0.95em;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .stat-value {
        font-size: 2.5em;
        font-weight: 700;
        margin-bottom: 15px;
        font-family: "Poppins", sans-serif;
        transition: all 0.5s ease;
        position: relative;
      }

      .stat-value.changed {
        animation: statChange 1s ease-out;
      }

      .stat-value.increased {
        color: var(--success-color);
        text-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
      }

      .stat-value.decreased {
        color: var(--danger-color);
        text-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
      }

      @keyframes statChange {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Change Indicator */
      .stat-change {
        position: absolute;
        top: -10px;
        right: -10px;
        background: var(--success-color);
        color: white;
        border-radius: 50%;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8em;
        font-weight: 700;
        animation: changeIndicator 2s ease-out;
      }

      .stat-change.negative {
        background: var(--danger-color);
      }

      @keyframes changeIndicator {
        0% {
          opacity: 0;
          transform: scale(0) rotate(180deg);
        }
        20% {
          opacity: 1;
          transform: scale(1.2) rotate(0deg);
        }
        100% {
          opacity: 0;
          transform: scale(0.8) rotate(0deg);
        }
      }

      /* Effect Items in Choices */
      .effect-item {
        display: inline-block;
        padding: 2px 6px;
        margin: 0 2px;
        background: rgba(99, 102, 241, 0.1);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: 500;
      }

      .effect-item.high-impact-effect {
        background: rgba(239, 68, 68, 0.15);
        border-color: var(--danger-color);
        color: var(--danger-color);
        font-weight: 700;
        animation: highImpactEffect 2s infinite;
      }

      @keyframes highImpactEffect {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      /* Demo Animation */
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%) scale(0.8);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      /* Random Event Animations */
      @keyframes eventSlideIn {
        0% {
          opacity: 0;
          transform: translate(-50%, -60%) scale(0.7) rotate(5deg);
          filter: blur(10px);
        }
        50% {
          transform: translate(-50%, -45%) scale(1.05) rotate(0deg);
          filter: blur(2px);
        }
        100% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
          filter: blur(0px);
        }
      }

      @keyframes eventSlideOut {
        0% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -30%) scale(0.8);
          filter: blur(5px);
        }
      }

      @keyframes eventTitleGlow {
        0%,
        100% {
          text-shadow: 0 0 20px currentColor;
          transform: scale(1);
        }
        50% {
          text-shadow: 0 0 30px currentColor, 0 0 40px currentColor;
          transform: scale(1.02);
        }
      }

      .stat-bar {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
      }

      .stat-bar::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .stat-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--success-color), var(--accent-color));
        border-radius: 3px;
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      /* Stat Status Colors */
      .stat.critical {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(239, 68, 68, 0.1) 100%);
        border: 2px solid var(--danger-color);
        animation: criticalPulse 2s infinite;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
      }

      .stat.warning {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(245, 158, 11, 0.08) 100%);
        border: 2px solid var(--warning-color);
        animation: warningGlow 3s infinite;
      }

      .stat.good {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(16, 185, 129, 0.08) 100%);
        border: 2px solid var(--success-color);
      }

      @keyframes criticalPulse {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 30px rgba(239, 68, 68, 0.6);
        }
      }

      @keyframes warningGlow {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(245, 158, 11, 0.5);
        }
      }

      .stat-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        animation: fillShimmer 3s infinite;
      }

      @keyframes fillShimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      /* Game Info */
      .game-info {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 0;
        padding: 20px;
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        border-radius: 16px;
        border: 1px solid var(--border-color);
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        width: 100%;
        box-sizing: border-box;
      }

      .reload-btn {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
        border: 1px solid var(--primary-color);
        color: var(--text-primary);
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 500;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .reload-btn:hover {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        border-color: var(--primary-color);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px var(--shadow-color);
      }

      .demo-btn {
        background: linear-gradient(135deg, var(--warning-color), #d97706);
        border: 1px solid var(--warning-color);
        color: white;
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        animation: demoGlow 3s infinite;
      }

      .demo-btn:hover {
        background: linear-gradient(135deg, #d97706, #b45309);
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
      }

      @keyframes demoGlow {
        0%,
        100% {
          box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        50% {
          box-shadow: 0 6px 25px rgba(245, 158, 11, 0.5);
        }
      }

      .change-difficulty-btn {
        background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
        border: 1px solid var(--secondary-color);
        color: white;
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        animation: changeModeGlow 3s infinite;
      }

      .change-difficulty-btn:hover {
        background: linear-gradient(135deg, var(--accent-color), var(--secondary-color));
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
      }

      @keyframes changeModeGlow {
        0%,
        100% {
          box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }
        50% {
          box-shadow: 0 6px 25px rgba(139, 92, 246, 0.5);
        }
      }

      .debug-btn {
        background: linear-gradient(135deg, var(--accent-color), var(--success-color));
        border: 1px solid var(--accent-color);
        color: white;
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .debug-btn:hover {
        background: linear-gradient(135deg, var(--success-color), var(--accent-color));
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 8px 25px rgba(6, 214, 160, 0.4);
      }

      .turn-counter,
      .scenario-counter {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--warning-color);
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        padding: 8px 16px;
        background: rgba(245, 158, 11, 0.1);
        border-radius: 20px;
        border: 1px solid rgba(245, 158, 11, 0.3);
        transition: all 0.3s ease;
      }

      /* Late Game Warning */
      .turn-counter.late-game {
        color: var(--danger-color);
        background: rgba(239, 68, 68, 0.15);
        border-color: var(--danger-color);
        animation: lateGamePulse 2s infinite;
      }

      @keyframes lateGamePulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .scenario-counter {
        color: var(--success-color);
        background: rgba(16, 185, 129, 0.1);
        border-color: rgba(16, 185, 129, 0.3);
      }

      .game-score {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--accent-color);
        padding: 8px 16px;
        background: rgba(6, 214, 160, 0.1);
        border-radius: 20px;
        border: 1px solid rgba(6, 214, 160, 0.3);
      }

      /* Story Section */
      .story-section {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.04) 100%);
        padding: 35px;
        border-radius: 20px;
        margin-bottom: 0;
        border: 1px solid var(--border-color);
        position: relative;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }

      .story-section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        border-radius: 20px 20px 0 0;
      }

      .story-section.loading {
        opacity: 0.7;
        transform: scale(0.98);
        filter: blur(0.5px);
      }

      .story-title {
        font-size: 1.8em;
        font-weight: 600;
        margin-bottom: 20px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
        letter-spacing: -0.01em;
      }

      .story-text {
        font-size: 1.15em;
        line-height: 1.7;
        margin-bottom: 25px;
        color: var(--text-secondary);
      }

      /* Choices */
      .choices-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
        margin-bottom: 0;
        width: 100%;
      }

      .choice {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%);
        padding: 30px;
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        border: 2px solid var(--border-color);
        transform: translateY(0);
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }

      .choice::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.6s ease;
      }

      .choice:hover:not(.disabled)::before {
        left: 100%;
      }

      .choice.disabled {
        pointer-events: none;
        opacity: 0.4;
        transform: scale(0.95);
        filter: grayscale(70%);
        background: rgba(100, 100, 100, 0.05);
      }

      .choice:hover:not(.disabled) {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
        border-color: var(--primary-color);
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 15px 40px rgba(99, 102, 241, 0.2);
      }

      /* High Impact Choices */
      .choice.high-impact {
        border: 2px solid var(--danger-color);
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);
        animation: highImpactGlow 3s infinite;
      }

      .choice.high-impact .choice-title {
        color: var(--danger-color);
        font-weight: 700;
      }

      .choice.high-impact .choice-effects {
        background: rgba(239, 68, 68, 0.15);
        border: 1px solid var(--danger-color);
        color: var(--text-primary);
        font-weight: 600;
      }

      @keyframes highImpactGlow {
        0%,
        100% {
          box-shadow: 0 4px 20px rgba(239, 68, 68, 0.2);
        }
        50% {
          box-shadow: 0 8px 30px rgba(239, 68, 68, 0.4);
        }
      }

      .choice-title {
        font-size: 1.3em;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
      }

      .choice-text {
        line-height: 1.6;
        margin-bottom: 20px;
        color: var(--text-secondary);
      }

      .choice-effects {
        font-size: 0.95em;
        color: var(--text-muted);
        background: rgba(0, 0, 0, 0.2);
        padding: 12px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-weight: 500;
      }

      /* Random Event */
      .random-event {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        color: var(--text-primary);
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        animation: eventSlideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6), 0 0 0 1px var(--border-color);
        border: 2px solid var(--primary-color);
        max-width: 700px;
        width: 90%;
        z-index: 1500;
        display: none;
        backdrop-filter: blur(20px);
        position: relative;
        overflow: hidden;
      }

      @keyframes eventSlideIn {
        from {
          transform: translate(-50%, -60%) scale(0.8);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      .random-event::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        animation: eventGlow 2s ease-in-out infinite;
      }

      @keyframes eventGlow {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
      }

      .event-title {
        font-size: 1.8em;
        font-weight: 700;
        margin-bottom: 20px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
        letter-spacing: -0.01em;
        position: relative;
        z-index: 1;
      }

      .event-description {
        font-size: 1.2em;
        line-height: 1.6;
        margin-bottom: 25px;
        color: var(--text-secondary);
        position: relative;
        z-index: 1;
      }

      .event-effects {
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.2) 100%);
        padding: 25px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        backdrop-filter: blur(10px);
        position: relative;
        z-index: 1;
      }

      .effects-title {
        font-size: 1.1em;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .effects-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
        font-size: 0.95em;
      }

      .effect-item {
        padding: 12px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
        border-radius: 8px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
      }

      .effect-item:hover {
        transform: scale(1.05);
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.1) 100%);
      }

      .effect-positive {
        color: var(--success-color);
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
      }

      .effect-negative {
        color: var(--danger-color);
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      }

      .effect-neutral {
        color: var(--warning-color);
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
      }

      /* Game End */
      .game-end {
        text-align: center;
        padding: 50px;
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        border-radius: 24px;
        margin-top: 40px;
        border: 1px solid var(--border-color);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(20px);
        position: relative;
        overflow: hidden;
      }

      .game-end::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        animation: endingGlow 3s ease-in-out infinite;
      }

      @keyframes endingGlow {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      .game-end h2 {
        font-size: 3em;
        margin-bottom: 25px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
        font-weight: 700;
        letter-spacing: -0.02em;
        position: relative;
        z-index: 1;
      }

      .ending-description {
        font-size: 1.4em;
        line-height: 1.7;
        margin-bottom: 40px;
        color: var(--text-secondary);
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        z-index: 1;
      }

      .restart-btn {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
        border: none;
        padding: 18px 40px;
        font-size: 1.2em;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        font-family: "Poppins", sans-serif;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        position: relative;
        z-index: 1;
        overflow: hidden;
      }

      .restart-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
      }

      .restart-btn:hover::before {
        left: 100%;
      }

      .restart-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px var(--shadow-color);
      }

      /* Responsive Design */
      @media (max-width: 1200px) {
        .container {
          padding: 20px;
        }

        .header h1 {
          font-size: 3em;
        }

        .game-layout {
          grid-template-columns: 320px 1fr;
          gap: 25px;
        }

        .stats-panel {
          padding: 20px;
        }
      }

      @media (max-width: 992px) {
        .game-layout {
          grid-template-columns: 1fr;
          gap: 30px;
        }

        .left-panel {
          position: static;
          order: 1;
        }

        .right-panel {
          order: 2;
          min-height: auto;
        }

        .stats-panel {
          grid-template-columns: repeat(3, 1fr);
          gap: 15px;
        }

        .game-info {
          flex-direction: row;
          flex-wrap: wrap;
          justify-content: space-between;
        }
      }

      @media (max-width: 768px) {
        .container {
          padding: 15px;
          max-width: 100%;
        }

        .start-title {
          font-size: 2.5em;
        }

        .header h1 {
          font-size: 2.3em;
        }

        .game-layout {
          grid-template-columns: 1fr;
          gap: 20px;
        }

        .stats-panel {
          grid-template-columns: repeat(2, 1fr);
          gap: 12px;
          padding: 18px;
        }

        .stat {
          padding: 15px 10px;
        }

        .stat-value {
          font-size: 1.8em;
        }

        .choice {
          padding: 20px;
        }

        .game-info {
          flex-direction: column;
          gap: 10px;
          padding: 15px;
          text-align: center;
        }

        .turn-counter,
        .scenario-counter,
        .game-score {
          font-size: 1em;
          padding: 8px 12px;
        }

        .difficulty-modal,
        .guide-content {
          margin: 10px;
          padding: 25px;
          width: calc(100% - 20px);
        }

        .story-section {
          padding: 20px;
        }

        .random-event {
          padding: 25px;
          width: calc(100% - 20px);
          margin: 10px;
        }

        .game-end {
          padding: 30px;
        }

        .game-end h2 {
          font-size: 2.2em;
        }
      }

      @media (max-width: 480px) {
        .container {
          padding: 10px;
        }

        .start-title {
          font-size: 2em;
        }

        .header h1 {
          font-size: 1.8em;
        }

        .game-layout {
          gap: 15px;
        }

        .stats-panel {
          grid-template-columns: 1fr;
          gap: 8px;
          padding: 15px;
        }

        .stat {
          padding: 12px 8px;
        }

        .stat-value {
          font-size: 1.6em;
        }

        .choice {
          padding: 18px;
        }

        .story-section {
          padding: 18px;
        }

        .game-info {
          padding: 12px;
          gap: 8px;
        }

        .random-event {
          padding: 20px;
          width: calc(100% - 20px);
        }

        .game-end {
          padding: 20px;
        }

        .game-end h2 {
          font-size: 1.8em;
        }

        .difficulty-modal,
        .guide-content {
          margin: 5px;
          padding: 20px;
          width: calc(100% - 10px);
        }

        .turn-counter,
        .scenario-counter,
        .game-score {
          font-size: 0.9em;
          padding: 6px 10px;
        }
      }

      /* Dark mode optimizations */
      @media (prefers-color-scheme: dark) {
        :root {
          --background-dark: #0a0a0f;
          --background-secondary: #151525;
          --background-light: #202040;
        }
      }

      /* High contrast mode */
      @media (prefers-contrast: high) {
        :root {
          --border-color: #666;
          --text-secondary: #fff;
        }

        .choice,
        .stat,
        .story-section {
          border-width: 2px;
        }
      }

      /* Reduced motion */
      @media (prefers-reduced-motion: reduce) {
        * {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }
    </style>
  </head>
  <body>
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
      <h1 class="start-title">NG∆Ø·ªúI C·∫¶M QUY·ªÄN</h1>
      <p class="start-subtitle">üéÆ Simulator Ch√≠nh Tr·ªã Chi·∫øn L∆∞·ª£c üéÆ</p>
      <button class="start-btn" onclick="showDifficultySelection()">
        <span>üöÄ B·∫ÆT ƒê·∫¶U GAME</span>
      </button>
    </div>

    <!-- Guide Button -->
    <button class="guide-btn" onclick="openGuide()" id="guideBtn">H∆Ø·ªöNG D·∫™N</button>

    <!-- Guide Modal -->
    <div class="guide-modal" id="guideModal">
      <div class="guide-content">
        <h2 class="guide-title">H∆Ø·ªöNG D·∫™N GAME</h2>

        <div class="guide-section">
          <h3>C√°ch Ch∆°i C∆° B·∫£n</h3>
          <p><strong>M·ª•c ti√™u:</strong> Duy tr√¨ quy·ªÅn l·ª±c v√† d·∫´n d·∫Øt ƒë·∫•t n∆∞·ªõc th√¥ng qua c√°c quy·∫øt ƒë·ªãnh ch√≠nh tr·ªã.</p>
          <p><strong>C∆° ch·∫ø:</strong> M·ªói l∆∞·ª£t, b·∫°n s·∫Ω ƒë·ªëi m·∫∑t v·ªõi c√°c t√¨nh hu·ªëng v√† ph·∫£i ch·ªçn 1 trong 2-3 l·ª±a ch·ªçn.</p>
          <p>
            <strong>Ch·ªâ s·ªë quan tr·ªçng:</strong> Qu·∫£n l√Ω 6 ch·ªâ s·ªë - B·∫•t M√£n, Xung ƒê·ªôt, Kinh T·∫ø, M√¥i Tr∆∞·ªùng, T·ª± Do, An
            Ninh.
          </p>
        </div>

        <div class="guide-section">
          <h3>ƒê·ªô Kh√≥</h3>
          <p>
            <strong>Easy Mode (15 rounds):</strong> T√°c ƒë·ªông ti√™u c·ª±c gi·∫£m 30%, t√°c ƒë·ªông t√≠ch c·ª±c tƒÉng 20%, √≠t s·ª± ki·ªán
            ng·∫´u nhi√™n
          </p>
          <p>
            <strong>Normal Mode (30 rounds):</strong> C√¢n b·∫±ng ho√†n h·∫£o, t√°c ƒë·ªông chu·∫©n, v·ª´a ph·∫£i s·ª± ki·ªán ng·∫´u nhi√™n
          </p>
          <p>
            <strong>Hard Mode (50 rounds):</strong> T√°c ƒë·ªông ti√™u c·ª±c tƒÉng 40%, t√°c ƒë·ªông t√≠ch c·ª±c gi·∫£m 20%, nhi·ªÅu s·ª±
            ki·ªán ng·∫´u nhi√™n
          </p>
        </div>

        <div class="guide-section">
          <h3>C√°c K·∫øt Th√∫c C√≥ Th·ªÉ G·∫∑p</h3>

          <div class="ending-item ending-success">
            <h4>NH√Ä L√ÉNH ƒê·∫†O T√ÄI BA - BEST LEADER EVER</h4>
            <p>
              <strong>ƒêi·ªÅu ki·ªán:</strong> B·∫•t M√£n ‚â§20, Xung ƒê·ªôt ‚â§25, Kinh T·∫ø ‚â•70, M√¥i Tr∆∞·ªùng ‚â•60, T·ª± Do ‚â•65, An Ninh ‚â•60
            </p>
            <p>K·∫øt th√∫c ho√†n h·∫£o nh·∫•t! B·∫°n c√¢n b·∫±ng xu·∫•t s·∫Øc t·∫•t c·∫£ c√°c y·∫øu t·ªë x√£ h·ªôi.</p>
          </div>

          <div class="ending-item ending-special">
            <h4>ƒê·ªòC T√ÄI QU√ÇN S·ª∞ (T·∫†M TH·ªúI)</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> An Ninh ‚â•75, T·ª± Do ‚â§25</p>
            <p>D·∫´n ƒë·∫øn ending Hitler Collapse sau 2 gi√¢y. Quy·ªÅn l·ª±c tuy·ªát ƒë·ªëi kh√¥ng b·ªÅn v·ªØng.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>H·∫¨U QU·∫¢ C·ª¶A ƒê·ªòC T√ÄI - DICTATOR'S COLLAPSE</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Sau khi tr·ªü th√†nh ƒë·ªôc t√†i</p>
            <p>"You look like Hitler after this you will collapse!" - C√°ch m·∫°ng l·∫≠t ƒë·ªï ch·∫ø ƒë·ªô ƒë·ªôc t√†i.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>C√ÅCH M·∫†NG B√ôNG N·ªî</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Xung ƒê·ªôt ‚â•85</p>
            <p>Ng∆∞·ªùi d√¢n n·ªïi d·∫≠y v√† l·∫≠t ƒë·ªï ch√≠nh quy·ªÅn khi xung ƒë·ªôt x√£ h·ªôi qu√° cao.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>M·∫§T QUY·ªÄN L·ª∞C</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> B·∫•t M√£n ‚â•80</p>
            <p>D√¢n ch√∫ng b·∫•t m√£n t·ªõi m·ª©c tru·∫•t ph·∫ø b·∫°n kh·ªèi ch·ª©c v·ª•.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>S·ª§P ƒê·ªî KINH T·∫æ</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Kinh T·∫ø ‚â§10</p>
            <p>N·ªÅn kinh t·∫ø s·ª•p ƒë·ªï ho√†n to√†n, ƒë·∫•t n∆∞·ªõc r∆°i v√†o kh·ªßng ho·∫£ng.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>TH·∫¢M H·ªåA M√îI TR∆Ø·ªúNG</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> M√¥i Tr∆∞·ªùng ‚â§10</p>
            <p>Bi·∫øn ƒë·ªïi kh√≠ h·∫≠u v√† √¥ nhi·ªÖm l√†m ƒë·∫•t n∆∞·ªõc kh√¥ng th·ªÉ sinh s·ªëng.</p>
          </div>

          <div class="ending-item ending-success">
            <h4>HO√ÄNG ƒê·∫æ KINH T·∫æ</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Kinh T·∫ø ‚â•85 (sau turn 10)</p>
            <p>Ph√°t tri·ªÉn n·ªÅn kinh t·∫ø m·∫°nh m·∫Ω, bi·∫øn ƒë·∫•t n∆∞·ªõc th√†nh c∆∞·ªùng qu·ªëc.</p>
          </div>

          <div class="ending-item ending-success">
            <h4>VUA B·∫¢O V·ªÜ M√îI TR∆Ø·ªúNG</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> M√¥i Tr∆∞·ªùng ‚â•85 (sau turn 10)</p>
            <p>Bi·∫øn ƒë·∫•t n∆∞·ªõc th√†nh thi√™n ƒë∆∞·ªùng xanh v·ªõi m√¥i tr∆∞·ªùng ho√†n h·∫£o.</p>
          </div>

          <div class="ending-item ending-special">
            <h4>K·∫æT TH√öC NHI·ªÜM K·ª≤</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Ho√†n th√†nh h·∫øt s·ªë rounds</p>
            <p>K·∫øt th√∫c t·ª± nhi√™n, ƒë√°nh gi√° d·ª±a tr√™n c√°c ch·ªâ s·ªë cu·ªëi game.</p>
          </div>
        </div>

        <div class="guide-section">
          <h3>ƒêi·ªÅu Ki·ªán Logic & S·ª± Ki·ªán C√≥ ƒêi·ªÅu Ki·ªán</h3>

          <h4>H·ªá Th·ªëng S·ª± Ki·ªán Th√¥ng Minh</h4>
          <p>
            Game s·ª≠ d·ª•ng h·ªá th·ªëng s·ª± ki·ªán c√≥ ƒëi·ªÅu ki·ªán logic, nghƒ©a l√† c√°c s·ª± ki·ªán ch·ªâ xu·∫•t hi·ªán khi c√°c ch·ªâ s·ªë ƒë·∫°t
            ng∆∞·ª°ng nh·∫•t ƒë·ªãnh:
          </p>

          <div class="ending-item ending-failure">
            <h4>S·ª± Ki·ªán An Ninh Th·∫•p</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> An Ninh ‚â§ 30</p>
            <p><strong>K√≠ch ho·∫°t:</strong> T·∫•n c√¥ng m·∫°ng, c∆∞·ªõp ng√¢n h√†ng, kh·ªßng b·ªë</p>
            <p>Khi an ninh y·∫øu k√©m, t·ªôi ph·∫°m gia tƒÉng v√† c√°c m·ªëi ƒëe d·ªça xu·∫•t hi·ªán</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>S·ª± Ki·ªán Kinh T·∫ø Kh·ªßng Ho·∫£ng</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Kinh T·∫ø ‚â§ 25</p>
            <p><strong>K√≠ch ho·∫°t:</strong> S·∫≠p ti·ªám v√†ng, kh·ªßng ho·∫£ng th·ª±c ph·∫©m, th·∫•t nghi·ªáp cao</p>
            <p>Suy tho√°i kinh t·∫ø d·∫´n ƒë·∫øn c√°c v·∫•n ƒë·ªÅ x√£ h·ªôi nghi√™m tr·ªçng</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>S·ª± Ki·ªán M√¥i Tr∆∞·ªùng X·∫•u</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> M√¥i Tr∆∞·ªùng ‚â§ 25</p>
            <p><strong>K√≠ch ho·∫°t:</strong> √î nhi·ªÖm s√¥ng, si√™u b√£o c·ª±c ƒëoan, th·∫£m h·ªça sinh th√°i</p>
            <p>M√¥i tr∆∞·ªùng t·ªìi t·ªá g√¢y ra c√°c thi√™n tai v√† √¥ nhi·ªÖm nghi√™m tr·ªçng</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>S·ª± Ki·ªán ƒê·ªôc T√†i</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> T·ª± Do ‚â§ 25 + An Ninh ‚â• 60</p>
            <p><strong>K√≠ch ho·∫°t:</strong> Bi·ªÉu t√¨nh ƒë√≤i d√¢n ch·ªß, ki·ªÉm duy·ªát b√°o ch√≠</p>
            <p>Ch·∫ø ƒë·ªô ƒë·ªôc t√†i g√¢y ph·∫£n ·ª©ng m·∫°nh m·∫Ω t·ª´ d√¢n ch√∫ng ƒë√≤i t·ª± do</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>S·ª± Ki·ªán B·∫°o Lo·∫°n</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Xung ƒê·ªôt ‚â• 60 + B·∫•t M√£n ‚â• 50</p>
            <p><strong>K√≠ch ho·∫°t:</strong> B·∫°o lo·∫°n th√†nh ph·ªë, ƒë·∫•u tranh v≈© trang</p>
            <p>CƒÉng th·∫≥ng x√£ h·ªôi cao d·∫´n ƒë·∫øn b·∫°o ƒë·ªông v√† m·∫•t tr·∫≠t t·ª±</p>
          </div>

          <div class="ending-item ending-success">
            <h4>S·ª± Ki·ªán T√≠ch C·ª±c</h4>
            <p><strong>ƒêi·ªÅu ki·ªán:</strong> Kinh T·∫ø ‚â• 70 + T·ª± Do ‚â• 60 + An Ninh ‚â• 60</p>
            <p><strong>K√≠ch ho·∫°t:</strong> ƒê·∫ßu t∆∞ n∆∞·ªõc ngo√†i, c√¥ng nh·∫≠n qu·ªëc t·∫ø</p>
            <p>M√¥i tr∆∞·ªùng ·ªïn ƒë·ªãnh thu h√∫t ƒë·∫ßu t∆∞ v√† ph√°t tri·ªÉn b·ªÅn v·ªØng</p>
          </div>

          <h4>C√°ch Th·ª©c Ho·∫°t ƒê·ªông</h4>
          <ul>
            <li><strong>Ki·ªÉm tra ƒëi·ªÅu ki·ªán:</strong> M·ªói turn, h·ªá th·ªëng ki·ªÉm tra t·∫•t c·∫£ ƒëi·ªÅu ki·ªán</li>
            <li><strong>X√°c su·∫•t k√≠ch ho·∫°t:</strong> C√°c s·ª± ki·ªán c√≥ ƒëi·ªÅu ki·ªán c√≥ x√°c su·∫•t ri√™ng (60-90%)</li>
            <li><strong>T√°c ƒë·ªông k√©p:</strong> S·ª± ki·ªán v·ª´a ph·∫£n √°nh t√¨nh h√¨nh, v·ª´a l√†m t√¨nh h√¨nh x·∫•u h∆°n</li>
            <li><strong>Chu·ªói ph·∫£n ·ª©ng:</strong> M·ªôt s·ª± ki·ªán c√≥ th·ªÉ t·∫°o ƒëi·ªÅu ki·ªán cho s·ª± ki·ªán kh√°c</li>
          </ul>
        </div>

        <div class="guide-section">
          <h3>Chi·∫øn Thu·∫≠t & Tips</h3>

          <h4>Chi·∫øn L∆∞·ª£c C∆° B·∫£n</h4>
          <ul>
            <li><strong>C√¢n b·∫±ng l√† ch√¨a kh√≥a:</strong> ƒê·ª´ng ƒë·ªÉ b·∫•t k·ª≥ ch·ªâ s·ªë n√†o qu√° th·∫•p ho·∫∑c qu√° cao</li>
            <li><strong>∆Øu ti√™n Kinh T·∫ø:</strong> N·ªÅn kinh t·∫ø m·∫°nh gi√∫p gi·∫£i quy·∫øt nhi·ªÅu v·∫•n ƒë·ªÅ</li>
            <li><strong>Ki·ªÉm so√°t Xung ƒê·ªôt:</strong> Lu√¥n gi·ªØ d∆∞·ªõi 80, s·ª≠ d·ª•ng ƒë·ªëi tho·∫°i khi c·∫ßn</li>
            <li><strong>ƒê·∫ßu t∆∞ d√†i h·∫°n:</strong> M√¥i Tr∆∞·ªùng v√† Gi√°o D·ª•c t·∫°o n·ªÅn t·∫£ng b·ªÅn v·ªØng</li>
            <li><strong>Linh ho·∫°t:</strong> Th√≠ch ·ª©ng v·ªõi s·ª± ki·ªán ng·∫´u nhi√™n v√† ƒëi·ªÅu ch·ªânh chi·∫øn l∆∞·ª£c</li>
          </ul>

          <h4>Ph√≤ng Ng·ª´a Kh·ªßng Ho·∫£ng</h4>
          <ul>
            <li><strong>Gi√°m s√°t ch·ªâ s·ªë:</strong> Theo d√µi c√°c ch·ªâ s·ªë nguy hi·ªÉm (An Ninh, Kinh T·∫ø, T·ª± Do)</li>
            <li><strong>Can thi·ªáp k·ªãp th·ªùi:</strong> Kh√¥ng ƒë·ªÉ ch·ªâ s·ªë n√†o xu·ªëng qu√° th·∫•p</li>
            <li><strong>C√¢n b·∫±ng l·ª±c l∆∞·ª£ng:</strong> Tr√°nh t√¨nh tr·∫°ng m·ªôt ch·ªâ s·ªë qu√° cao, m·ªôt ch·ªâ s·ªë qu√° th·∫•p</li>
            <li><strong>Chu·∫©n b·ªã ·ª©ng ph√≥:</strong> D·ª± tr·ªØ ngu·ªìn l·ª±c ƒë·ªÉ x·ª≠ l√Ω kh·ªßng ho·∫£ng</li>
          </ul>
        </div>

        <button class="close-guide" onclick="closeGuide()">ƒê√ìNG</button>
      </div>
    </div>

    <!-- Main Game -->
    <div class="container" id="gameContainer" style="display: none">
      <!-- Header -->
      <div class="header">
        <h1>üèõÔ∏è NG∆Ø·ªúI C·∫¶M QUY·ªÄN üèõÔ∏è</h1>
        <div class="subtitle">‚öñÔ∏è Quy·∫øt ƒë·ªãnh t∆∞∆°ng lai ƒë·∫•t n∆∞·ªõc ‚öñÔ∏è</div>
      </div>

      <!-- Game Layout - 2 Columns -->
      <div class="game-layout">
        <!-- Left Column - Stats & Info -->
        <div class="left-panel">
          <div class="panel-title">üìä B·∫¢NG ƒêI·ªÄU KHI·ªÇN</div>

          <!-- Stats Panel -->
          <div class="stats-panel" id="statsPanel">
            <!-- Stats will be populated by JavaScript -->
          </div>

          <!-- Game Info -->
          <div class="game-info">
            <div class="turn-counter">L∆∞·ª£t <span id="turnCounter">1</span></div>
            <div class="scenario-counter">T√¨nh hu·ªëng: <span id="scenarioCount">2</span>/20</div>
            <div class="game-score">ƒêi·ªÉm <span id="gameScore">0</span></div>
            <button
              id="reloadDataBtn"
              class="reload-btn"
              onclick="reloadGameData()"
              title="T·∫£i l·∫°i d·ªØ li·ªáu game sau khi setup server"
            >
              üîÑ T·∫£i l·∫°i d·ªØ li·ªáu
            </button>
            <button onclick="demoRandomEvent()" class="demo-btn" title="Xem demo random event">üé≤ Demo Event</button>
            <button onclick="changeDifficulty()" class="change-difficulty-btn" title="ƒê·ªïi ƒë·ªô kh√≥ v√† reset game">
              ‚öôÔ∏è ƒê·ªïi Mode
            </button>
          </div>
        </div>

        <!-- Right Column - Story & Choices -->
        <div class="right-panel">
          <div class="panel-title">üìñ T√åNH HU·ªêNG & L·ª∞A CH·ªåN</div>

          <!-- Story Section -->
          <div class="story-section">
            <div class="story-title" id="storyTitle">B·∫Øt ƒë·∫ßu nhi·ªám k·ª≥</div>
            <div class="story-text" id="storyText">
              Ch√†o m·ª´ng ƒë·∫øn v·ªõi gh·∫ø quy·ªÅn l·ª±c. Nh·ªØng quy·∫øt ƒë·ªãnh c·ªßa b·∫°n s·∫Ω ƒë·ªãnh h√¨nh t∆∞∆°ng lai c·ªßa ƒë·∫•t n∆∞·ªõc.
            </div>
          </div>

          <!-- Choices -->
          <div class="choices-grid" id="choicesGrid">
            <!-- Choices will be populated by JavaScript -->
          </div>

          <div class="game-end" id="gameEnd" style="display: none">
            <h2 id="endingTitle">Game Over</h2>
            <div class="ending-description" id="endingDescription"></div>
            <button class="restart-btn" onclick="restartGame()">Ch∆°i l·∫°i</button>
          </div>
        </div>
      </div>

      <!-- Random Events now display as center screen popups -->

      <!-- Game End -->
      <!-- <div class="game-end" id="gameEnd" style="display: none">
        <h2 id="endingTitle">Game Over</h2>
        <div class="ending-description" id="endingDescription"></div>
        <button class="restart-btn" onclick="restartGame()">Ch∆°i l·∫°i</button>
      </div> -->
    </div>

    <script>
      // === DIFFICULTY MODES SYSTEM ===

      // Gemini AI Configuration
      const GEMINI_API_KEY = "AIzaSyC9gp_B0IZiOW1LBGtaFjGD9wnVmcuYxD0";
      // const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      // const apiKey = "YOUR_API_KEY";
      const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";
      let aiGeneratedStoryCache = [];

      // Global game state
      let currentDifficulty = "normal";
      let maxTurns = 30;
      let gameState = {
        turnMode: 1,
        currentTurn: 1,
        stats: {
          discontent: 45,
          conflict: 35,
          economy: 55,
          environment: 50,
          freedom: 60,
          security: 45,
        },
        score: 0,
        gameEnded: false,
        eventHistory: [],
        usedScenarios: [],
      };

      // Difficulty modes configuration - UPDATED ROUNDS
      const DIFFICULTY_MODES = {
        easy: {
          name: "D·ªÑ - Easy Mode",
          description: "B·∫Øt ƒë·∫ßu v·ªõi buffer t·ªët cho random events - Perfect for beginners",
          startingStats: {
            discontent: 30,
            conflict: 20,
            economy: 75,
            environment: 70,
            freedom: 75,
            security: 65,
          },
          effectMultiplier: 0.6, // Gi·∫£m t√°c ƒë·ªông ti√™u c·ª±c
          positiveBoost: 1.3, // TƒÉng t√°c ƒë·ªông t√≠ch c·ª±c
          randomEventsFrequency: 0.2, // ƒêi·ªÅu ch·ªânh cho ph√π h·ª£p
          maxTurns: 15, // UPDATED: 15 rounds
        },
        normal: {
          name: "B√åNH TH∆Ø·ªúNG - Normal Mode",
          description: "C√¢n b·∫±ng v·ªõi random events - Can breathe :D",
          startingStats: {
            discontent: 40,
            conflict: 30,
            economy: 60,
            environment: 55,
            freedom: 65,
            security: 50,
          },
          effectMultiplier: 1.0,
          positiveBoost: 1.0,
          randomEventsFrequency: 0.3, // C√¢n b·∫±ng v·ªõi buffer stats
          maxTurns: 30, // UPDATED: 30 rounds
        },
        hard: {
          name: "KH√ì - Hard Mode",
          description: "Th·ª≠ th√°ch v·ªõi nhi·ªÅu random events - Most hard to play",
          startingStats: {
            discontent: 50,
            conflict: 40,
            economy: 50,
            environment: 45,
            freedom: 55,
            security: 40,
          },
          effectMultiplier: 1.3, // Gi·∫£m xu·ªëng ƒë·ªÉ c√¢n b·∫±ng
          positiveBoost: 0.9, // C·∫£i thi·ªán ƒë·ªÉ kh√¥ng qu√° kh√≥
          randomEventsFrequency: 0.4, // V·∫´n cao nh∆∞ng kh√¥ng qu√° m·ª©c
          maxTurns: 50, // UPDATED: 50 rounds
        },
      };

      // Stat labels
      const statLabels = {
        discontent: "üî• B·∫•t M√£n",
        conflict: "‚öîÔ∏è Xung ƒê·ªôt",
        economy: "üí∞ Kinh T·∫ø",
        environment: "üåç M√¥i Tr∆∞·ªùng",
        freedom: "üóΩ T·ª± Do",
        security: "üõ°Ô∏è An Ninh",
      };

      // Game data
      let gameStoryData = [];
      let randomEventsWithChoicesData = [];

      // Event tracking to prevent repetition
      let usedEvents = new Set();
      let lastEventTurn = 0;
      let eventCooldown = 2; // Gi·∫£m cooldown ƒë·ªÉ events xu·∫•t hi·ªán th∆∞·ªùng xuy√™n h∆°n
      let minEventTurn = 3; // Events kh√¥ng trigger tr∆∞·ªõc l∆∞·ª£t 3
      let endingsData = [];
      let dictatorModeTriggered = false;
      let triggeredEndings = new Set(); // Track endings ƒë√£ ƒë∆∞·ª£c trigger

      // Demo function to trigger random event immediately
      function demoRandomEvent() {
        console.log("üé™ Demo: Triggering random event...");

        if (randomEventsWithChoicesData.length > 0) {
          // Pick a random event for demo
          const randomEvent =
            randomEventsWithChoicesData[Math.floor(Math.random() * randomEventsWithChoicesData.length)];

          // Create demo event display
          const demoDiv = document.createElement("div");
          demoDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            padding: 30px;
            border-radius: 20px;
            border: 2px solid #f59e0b;
            max-width: 650px;
            z-index: 10000;
            box-shadow: 0 25px 60px rgba(0,0,0,0.7);
            animation: slideIn 0.5s ease-out;
            backdrop-filter: blur(10px);
          `;

          // Determine event severity color
          const isHighImpact = Object.values(randomEvent.effects).some((val) => Math.abs(val) >= 15);
          const severityColor = isHighImpact ? "#ef4444" : "#f59e0b";
          const severityIcon = isHighImpact ? "üí•" : "‚ö°";

          demoDiv.innerHTML = `
            <div style="text-align: center; margin-bottom: 25px;">
              <h2 style="color: ${severityColor}; margin-bottom: 10px; font-size: 1.5em;">
                ${severityIcon} RANDOM EVENT DEMO ${severityIcon}
              </h2>
              <div style="background: rgba(245, 158, 11, 0.1); padding: 8px 16px; border-radius: 20px; display: inline-block; font-size: 0.9em; color: #f59e0b;">
                ID: ${randomEvent.id} | ${randomEvent.rarity?.toUpperCase() || "NORMAL"}
              </div>
            </div>
            
            <h3 style="color: #f59e0b; margin-bottom: 15px; text-align: center; font-size: 1.4em;">
              ${randomEvent.title}
            </h3>
            
            <p style="margin-bottom: 25px; line-height: 1.6; text-align: center; font-size: 1.1em; color: #e2e8f0;">
              ${randomEvent.text}
            </p>
            
            <div style="background: rgba(99, 102, 241, 0.1); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 1px solid rgba(99, 102, 241, 0.3);">
              <h4 style="color: #6366f1; margin-bottom: 15px; text-align: center;">üìä T√°c ƒê·ªông L√™n Ch·ªâ S·ªë:</h4>
              <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                ${Object.entries(randomEvent.effects)
                  .map(
                    ([stat, change]) =>
                      `<span style="
                    display: inline-block; 
                    padding: 8px 12px; 
                    background: ${change > 0 ? "rgba(239, 68, 68, 0.2)" : "rgba(16, 185, 129, 0.2)"}; 
                    border: 1px solid ${change > 0 ? "#ef4444" : "#10b981"};
                    border-radius: 20px; 
                    color: ${change > 0 ? "#ef4444" : "#10b981"};
                    font-weight: 600;
                    font-size: 0.95em;
                    ${Math.abs(change) >= 15 ? "animation: highImpactEffect 2s infinite;" : ""}
                  ">
                    ${statLabels[stat] || stat}: ${change > 0 ? "+" : ""}${change}
                  </span>`
                  )
                  .join("")}
              </div>
            </div>
            
            ${
              randomEvent.conditions
                ? `
              <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px; border: 1px solid rgba(139, 92, 246, 0.3);">
                <h5 style="color: #8b5cf6; margin-bottom: 10px; text-align: center;">üéØ ƒêi·ªÅu Ki·ªán K√≠ch Ho·∫°t:</h5>
                <div style="font-size: 0.9em; color: #cbd5e1; text-align: center;">
                  ${Object.entries(randomEvent.conditions)
                    .filter(([key]) => key !== "min_turn")
                    .map(([stat, condition]) => {
                      if (typeof condition === "object") {
                        return `${statLabels[stat] || stat}: ${condition.min ? "‚â•" + condition.min : ""}${
                          condition.max ? "‚â§" + condition.max : ""
                        }`;
                      }
                      return `${stat}: ${condition}`;
                    })
                    .join(" ‚Ä¢ ")}
                  ${randomEvent.conditions.min_turn ? `‚Ä¢ T·ª´ l∆∞·ª£t ${randomEvent.conditions.min_turn}` : ""}
                </div>
              </div>
            `
                : ""
            }
            
            <div style="text-align: center;">
              <button onclick="this.parentElement.parentElement.remove()" 
                      style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; padding: 15px 30px; border-radius: 25px; cursor: pointer; font-weight: 600; font-size: 1.1em; transition: all 0.3s ease;">
                üéÆ ƒê√≥ng Demo
              </button>
            </div>
          `;

          document.body.appendChild(demoDiv);

          // Add hover effect to close button
          const closeBtn = demoDiv.querySelector("button");
          closeBtn.addEventListener("mouseenter", function () {
            this.style.transform = "scale(1.05)";
            this.style.boxShadow = "0 8px 25px rgba(245, 158, 11, 0.4)";
          });
          closeBtn.addEventListener("mouseleave", function () {
            this.style.transform = "scale(1)";
            this.style.boxShadow = "none";
          });
        } else {
          // Fallback demo with sample data if events not loaded
          const sampleEvent = {
            id: "DEMO",
            title: "DEMO: T·∫§N C√îNG M·∫†NG QUY M√î L·ªöN!",
            text: "ƒê√¢y l√† demo m·ªôt random event. Nh√≥m hacker qu·ªëc t·∫ø t·∫•n c√¥ng h·ªá th·ªëng ng√¢n h√†ng do h·ªá th·ªëng b·∫£o m·∫≠t y·∫øu k√©m!",
            effects: {
              discontent: 15,
              conflict: 10,
              economy: -12,
              freedom: -8,
              security: -10,
            },
            rarity: "conditional",
            conditions: {
              security: { max: 30 },
              min_turn: 3,
            },
          };

          // Use sample event for demo
          alert("ƒêang load demo event... Random events data ch∆∞a s·∫µn s√†ng!");
          console.log("Sample demo event:", sampleEvent);
        }
      }

      // Function to change difficulty (auto-reset stats)
      function changeDifficulty() {
        if (confirm("‚öôÔ∏è B·∫°n c√≥ mu·ªën ƒë·ªïi ƒë·ªô kh√≥ kh√¥ng? Game s·∫Ω ƒë∆∞·ª£c reset v√† √°p d·ª•ng ch·ªâ s·ªë m·ªõi.")) {
          console.log("‚öôÔ∏è Changing difficulty...");

          // Hide current game
          document.getElementById("gameContainer").style.display = "none";

          // Show difficulty selection again v·ªõi ch·∫ø ƒë·ªô reset
          showDifficultySelection(true); // true = reset mode

          console.log("‚úÖ Difficulty selection shown");
        }
      }

      // Function ri√™ng ƒë·ªÉ RESET v√† ch·ªçn mode m·ªõi
      function selectDifficultyAndReset(difficulty) {
        currentDifficulty = difficulty;
        const mode = DIFFICULTY_MODES[difficulty];

        console.log(`üîÑ RESETTING game and selecting difficulty: ${difficulty}`, mode);

        // RESET HO√ÄN TO√ÄN game state
        gameState = {
          turnMode: mode.maxTurns,
          currentTurn: 1,
          usedScenarios: [],
          stats: { ...mode.startingStats },
          score: 0,
        };

        maxTurns = mode.maxTurns;

        // Reset events tracking
        usedEvents.clear();
        lastEventTurn = 0;

        // Remove difficulty selection screen
        const difficultyModal = document.getElementById("difficultySelection");
        if (difficultyModal) {
          difficultyModal.remove();
        }

        // Remove existing difficulty indicator if any
        const existingIndicator = document.getElementById("difficulty-indicator");
        if (existingIndicator) {
          existingIndicator.remove();
        }

        // Show new difficulty indicator
        showDifficultyIndicator(mode.name);

        console.log(`‚úÖ Game RESET with new stats:`, gameState.stats);

        // ‚ú® C·∫¨P NH·∫¨T UI V·ªöI STATS M·ªöI
        updateDisplay();

        // Start game
        startGame();
      }

      // Function to show difficulty selection screen
      function showDifficultySelection(resetMode = false) {
        document.getElementById("startScreen").classList.add("hidden");

        const functionToCall = resetMode ? "selectDifficultyAndReset" : "selectDifficulty";
        const titleText = resetMode ? "üîÑ ƒê·ªîI ƒê·ªò KH√ì & RESET" : "üéÆ CH·ªåN ƒê·ªò KH√ì";

        const difficultyHTML = `
        <div class="difficulty-selection" id="difficultySelection">
          <div class="difficulty-modal">
            <h2 style="color: #fff; margin-bottom: 20px; font-size: 2rem;">${titleText}</h2>
            <p style="color: #ccc; margin-bottom: 30px;">SELECT DIFFICULTY MODE</p>
            
            <div class="difficulty-options">
              ${Object.entries(DIFFICULTY_MODES)
                .map(
                  ([key, mode]) => `
                <div class="difficulty-option" onclick="${functionToCall}('${key}')">
                  <h3>${mode.name}</h3>
                  <p>${mode.description}</p>
                  <div class="difficulty-stats">
                    Economy ${mode.startingStats.economy} | Security ${mode.startingStats.security} | Freedom ${
                    mode.startingStats.freedom
                  } | 
                    Rounds: ${mode.maxTurns} | 
                    Events: ${Math.round(mode.randomEventsFrequency * 100)}%
                  </div>
                </div>
              `
                )
                .join("")}
            </div>
          </div>
        </div>`;

        document.body.insertAdjacentHTML("beforeend", difficultyHTML);
      }

      // Function ƒë·ªÉ ch·ªçn mode L·∫¶N ƒê·∫¶U (kh√¥ng reset game ƒë√£ c√≥)
      function selectDifficulty(difficulty) {
        currentDifficulty = difficulty;
        const mode = DIFFICULTY_MODES[difficulty];

        console.log(`üéÆ First time selecting difficulty: ${difficulty}`, mode);

        // Ch·ªâ setup game state n·∫øu ch∆∞a c√≥ game n√†o ƒëang ch·∫°y
        if (!gameState || gameState.currentTurn === 1) {
          console.log(`üìä Setting up NEW game with stats:`, mode.startingStats);
          gameState = {
            currentTurn: 1,
            usedScenarios: [],
            stats: { ...mode.startingStats },
            score: 0,
          };
        } else {
          // N·∫øu ƒëang c√≥ game, CH·ªà c·∫≠p nh·∫≠t difficulty settings
          console.log(`üîÑ Game ƒëang ch·∫°y, ch·ªâ c·∫≠p nh·∫≠t difficulty settings`);
        }

        maxTurns = mode.maxTurns;

        // Remove difficulty selection screen
        const difficultyModal = document.getElementById("difficultySelection");
        if (difficultyModal) {
          difficultyModal.remove();
        }

        // Remove existing difficulty indicator if any
        const existingIndicator = document.getElementById("difficulty-indicator");
        if (existingIndicator) {
          existingIndicator.remove();
        }

        // Show difficulty indicator n·∫øu ch∆∞a c√≥
        if (!document.getElementById("difficulty-indicator")) {
          showDifficultyIndicator(mode.name);
        }

        console.log(`‚úÖ Difficulty selected (no reset):`, gameState?.stats || "No game state yet");

        // ‚ú® C·∫¨P NH·∫¨T UI (n·∫øu c√≥ gameState)
        if (gameState) {
          updateDisplay();
        }

        // Start game
        startGame();
      }

      // Function to show difficulty indicator
      function showDifficultyIndicator(difficultyName) {
        const indicator = `
        <div id="difficulty-indicator">
          üéÆ ${difficultyName}
        </div>`;

        document.body.insertAdjacentHTML("beforeend", indicator);
      }

      // Function to apply difficulty modifiers to effects
      function applyDifficultyModifiers(effects) {
        const mode = DIFFICULTY_MODES[currentDifficulty];
        const modifiedEffects = {};

        Object.entries(effects).forEach(([stat, value]) => {
          if (value > 0) {
            // Positive effect - apply positive boost
            modifiedEffects[stat] = Math.round(value * mode.positiveBoost);
          } else {
            // Negative effect - apply effect multiplier
            modifiedEffects[stat] = Math.round(value * mode.effectMultiplier);
          }
        });

        return modifiedEffects;
      }

      // Generate story using Gemini AI
      async function generateAIStory() {
        try {
          // Prepare context from game state
          const context = {
            turn: gameState.currentTurn,
            stats: gameState.stats,
            history: gameState.eventHistory?.slice(-5) || [],
            difficulty: currentDifficulty,
          };

          // Prompt ti·∫øng Vi·ªát cho t·∫°o c√¢u chuy·ªán
          const storyPrompt = `
B·∫°n l√† m·ªôt nh√† thi·∫øt k·∫ø k·ªãch b·∫£n game chuy√™n nghi·ªáp. H√£y t·∫°o m·ªôt s·ª± ki·ªán c√¢u chuy·ªán h·∫•p d·∫´n cho game chi·∫øn l∆∞·ª£c/m√¥ ph·ªèng.

B·ªêI C·∫¢NH GAME:
- L∆∞·ª£t hi·ªán t·∫°i: ${context.turn}
- Ch·ªâ s·ªë ng∆∞·ªùi ch∆°i: ${JSON.stringify(context.stats)}
- C√°c s·ª± ki·ªán g·∫ßn ƒë√¢y: ${JSON.stringify(context.history)}
- M·ª©c ƒë·ªô kh√≥: ${context.difficulty}

Y√äU C·∫¶U:
1. Vi·∫øt m·ªôt s·ª± ki·ªán c√¢u chuy·ªán h·∫•p d·∫´n (150-250 t·ª´):
   - Ph·∫£n √°nh t√¨nh tr·∫°ng game hi·ªán t·∫°i v√† ti·∫øn ƒë·ªô ng∆∞·ªùi ch∆°i
   - ƒê∆∞a ra h·∫≠u qu·∫£ c√≥ √Ω nghƒ©a d·ª±a tr√™n ch·ªâ s·ªë ng∆∞·ªùi ch∆°i
   - Ph√π h·ª£p v·ªõi m·ª©c ƒë·ªô kh√≥ ${context.difficulty}
   - T·∫°o ra cƒÉng th·∫≥ng v√† s·ª± tham gia

2. C√¢u chuy·ªán n√™n:
   - C√≥ c√¢u m·ªü ƒë·∫ßu k·ªãch t√≠nh
   - Bao g·ªìm chi ti·∫øt c·ª• th·ªÉ li√™n quan ƒë·∫øn t√¨nh hu·ªëng hi·ªán t·∫°i c·ªßa ng∆∞·ªùi ch∆°i
   - Tr√¨nh b√†y t√¨nh hu·ªëng th·ª≠ th√°ch c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn gameplay t∆∞∆°ng lai
   - K·∫øt th√∫c b·∫±ng m·ªôt t√¨nh hu·ªëng h·ªìi h·ªôp ho·∫∑c th·ªùi ƒëi·ªÉm quy·∫øt ƒë·ªãnh quan tr·ªçng

3. Gi·ªçng ƒëi·ªáu v√† phong c√°ch:
   - Vi·∫øt ·ªü ng√¥i th·ª© hai ("B·∫°n ph√°t hi·ªán...", "Qu√¥ÃÅc gia c·ªßa b·∫°n ƒë·ªëi m·∫∑t...")
   - S·ª≠ d·ª•ng ng√¥n ng·ªØ sinh ƒë·ªông, ƒë·∫Øm ch√¨m
   - C√¢n b·∫±ng gi·ªØa y·∫øu t·ªë k·ªãch t√≠nh v√† chi·∫øn l∆∞·ª£c
   - Duy tr√¨ t√≠nh nh·∫•t qu√°n v·ªõi c√°c s·ª± ki·ªán tr∆∞·ªõc ƒë√≥

4. Xem x√©t c√°c y·∫øu t·ªë n√†y:
   - N·∫øu ch·ªâ s·ªë cao: ƒê∆∞a ra c∆° h·ªôi tham v·ªçng ho·∫∑c m·ªëi ƒëe d·ªça l·ªõn h∆°n
   - N·∫øu ch·ªâ s·ªë th·∫•p: T·∫≠p trung v√†o k·ªãch b·∫£n sinh t·ªìn ho·∫∑c ph·ª•c h·ªìi
   - N·∫øu s·ªë l∆∞·ª£t cao: L√†m leo thang c√°c xung ƒë·ªôt hi·ªán c√≥
   - N·∫øu s·ªë l∆∞·ª£t th·∫•p: Gi·ªõi thi·ªáu nh·ªØng b√≠ ·∫©n m·ªõi ho·∫∑c n·ªÅn t·∫£ng

ƒê·ªäNH D·∫†NG M·∫™U:
"Khi b√¨nh minh l√≥ d·∫°ng tr√™n l√£nh th·ªï c·ªßa b·∫°n, m·ªôt s·ª© gi·∫£ ƒë·∫øn v·ªõi tin t·ª©c kh·∫©n c·∫•p s·∫Ω th·ª≠ th√°ch m·ªçi th·ª© b·∫°n ƒë√£ x√¢y d·ª±ng. [Ti·∫øp t·ª•c v·ªõi c√¢u chuy·ªán k·∫øt h·ª£p c√°c ch·ªâ s·ªë v√† t·∫°o ra nh·ªØng l·ª±a ch·ªçn c√≥ √Ω nghƒ©a...]"

H√£y t·∫°o s·ª± ki·ªán c√¢u chuy·ªán b·∫±ng ti·∫øng Vi·ªát ngay b√¢y gi·ªù:`;

          const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: storyPrompt,
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.9, // T√≠nh s√°ng t·∫°o cao
                topK: 40, // L·ª±a ch·ªçn t·ª´ ƒëa d·∫°ng
                topP: 0.95, // S√°ng t·∫°o nh∆∞ng t·∫≠p trung
                maxOutputTokens: 400, // Gi·ªõi h·∫°n ƒë·ªô d√†i ph·∫£n h·ªìi (tƒÉng cho ti·∫øng Vi·ªát)
              },
            }),
          });

          if (!response.ok) {
            const errorData = await response.json();
            console.error("API Error:", errorData);
            throw new Error(`AI API call failed: ${response.status}`);
          }

          const data = await response.json();
          const generatedStory = {
            title: "üé≠ S·ª± ki·ªán ƒë·∫∑c bi·ªát",
            description: data.candidates[0].content.parts[0].text,
            turn: gameState.currentTurn,
            timestamp: new Date().toISOString(),
          };

          aiGeneratedStoryCache.push(generatedStory);

          // Display the AI generated story
          showAIStoryEvent(generatedStory);
        } catch (error) {
          console.error("Failed to generate AI story:", error);

          // C√¢u chuy·ªán d·ª± ph√≤ng n·∫øu API l·ªói
          const fallbackStory = {
            title: "‚ö° S·ª± ki·ªán b·∫•t ng·ªù",
            description: `M·ªôt tin t·ª©c b·∫•t ng·ªù ƒë·∫øn t·ª´ v∆∞∆°ng qu·ªëc l√°ng gi·ªÅng trong l√∫c b·∫°n ƒëang ·ªü l∆∞·ª£t ${gameState.currentTurn}. T√¨nh h√¨nh hi·ªán t·∫°i ƒë√≤i h·ªèi b·∫°n ph·∫£i ƒë∆∞a ra quy·∫øt ƒë·ªãnh quan tr·ªçng d·ª±a tr√™n kh·∫£ nƒÉng v√† t√†i nguy√™n hi·ªán c√≥. ƒêi·ªÅu n√†y c√≥ th·ªÉ thay ƒë·ªïi ho√†n to√†n ti·∫øn tr√¨nh ph√°t tri·ªÉn c·ªßa ƒë·∫ø ch·∫ø b·∫°n...`,
            turn: gameState.currentTurn,
            timestamp: new Date().toISOString(),
          };
          showAIStoryEvent(fallbackStory);
        }
      }

      // Display AI generated story event
      function showAIStoryEvent(story) {
        const eventDiv = document.createElement("div");
        eventDiv.className = "ai-story-event";

        // Parse story ƒë·ªÉ t√°ch ph·∫ßn l·ª±a ch·ªçn n·∫øu c√≥
        const storyText = story.description;
        const hasChoices = storyText.includes("**L·ª±a ch·ªçn:**");
        let mainStory = storyText;
        let choices = "";

        if (hasChoices) {
          const parts = storyText.split("**L·ª±a ch·ªçn:**");
          mainStory = parts[0].trim();
          choices = parts[1].trim();
        }

        eventDiv.innerHTML = `
    <div class="ai-story-modal">
      <div class="modal-header">
        <div class="header-icon">üé≠</div>
        <h3>Bi√™n ni√™n s·ª≠ - L∆∞·ª£t ${story.turn}</h3>
        <div class="turn-badge">Turn ${story.turn}</div>
      </div>
      
      <div class="story-content">
        <div class="story-text">
          ${mainStory.replace(/\n/g, "<br>")}
        </div>
        
        ${
          choices
            ? `
          <div class="choices-section">
            <h4>üéØ L·ª±a ch·ªçn c·ªßa b·∫°n:</h4>
            <div class="choices-content">
              ${choices
                .replace(/\n/g, "<br>")
                .replace(/(\d+\.\s\*\*[^*]+\*\*)/g, '<div class="choice-option">$1</div>')}
            </div>
          </div>
        `
            : ""
        }
      </div>
      
      <div class="modal-footer">
        <button class="btn-primary" onclick="this.closest('.ai-story-event').remove()">
          ‚öîÔ∏è Ti·∫øp t·ª•c h√†nh tr√¨nh
        </button>
        <button class="btn-secondary" onclick="this.closest('.ai-story-event').remove()">
          üìñ Ghi nh·∫≠n
        </button>
      </div>
    </div>
  `;

        // ‚úÖ Ch·ªânh m√†u s·∫Øc ƒë·ªìng nh·∫•t v·ªõi theme ch√≠nh c·ªßa game
        const styles = document.createElement("style");
        styles.textContent = `
    .ai-story-event {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .ai-story-modal {
      background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
      border: 2px solid var(--primary-color);
      border-radius: 20px;
      max-width: 700px;
      max-height: 80vh;
      overflow-y: auto;
      color: var(--text-primary);
      box-shadow: 
        0 25px 60px rgba(0, 0, 0, 0.6),
        0 0 40px var(--shadow-color),
        inset 0 0 20px rgba(99, 102, 241, 0.1);
      position: relative;
      animation: slideIn 0.4s ease;
    }

    @keyframes slideIn {
      from { transform: translateY(-50px) scale(0.9); }
      to { transform: translateY(0) scale(1); }
    }

    .modal-header {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      padding: 1.5rem;
      border-radius: 18px 18px 0 0;
      display: flex;
      align-items: center;
      gap: 1rem;
      position: relative;
      border-bottom: 2px solid var(--accent-color);
    }

    .header-icon {
      font-size: 2rem;
      filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
      color: white;
    }

    .modal-header h3 {
      color: white;
      margin: 0;
      font-size: 1.5rem;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      flex: 1;
      font-family: 'Poppins', sans-serif;
    }

    .turn-badge {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.8rem;
      color: white;
      backdrop-filter: blur(10px);
    }

    .story-content {
      padding: 2rem;
      line-height: 1.7;
    }

    .story-text {
      font-size: 1rem;
      margin-bottom: 1.5rem;
      text-align: justify;
      color: var(--text-secondary);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%);
      padding: 1.5rem;
      border-radius: 12px;
      border-left: 4px solid var(--primary-color);
      backdrop-filter: blur(10px);
    }

    .choices-section {
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 2px solid var(--border-color);
    }

    .choices-section h4 {
      color: var(--primary-color);
      margin-bottom: 1rem;
      font-size: 1.2rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      text-align: center;
    }

    .choices-content {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      padding: 1rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      backdrop-filter: blur(10px);
    }

    .choice-option {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
      margin: 0.5rem 0;
      padding: 0.8rem;
      border-radius: 8px;
      border-left: 3px solid var(--accent-color);
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .choice-option:hover {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
      transform: translateX(5px);
      border-color: var(--primary-color);
      box-shadow: 0 4px 15px var(--shadow-color);
    }

    .modal-footer {
      background: linear-gradient(135deg, var(--background-secondary), var(--background-dark));
      padding: 1.5rem;
      border-radius: 0 0 18px 18px;
      display: flex;
      gap: 1rem;
      justify-content: center;
      border-top: 2px solid var(--border-color);
    }

    .btn-primary, .btn-secondary {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 12px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
      font-family: 'Poppins', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      box-shadow: 0 4px 15px var(--shadow-color);
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      transform: translateY(-2px);
      box-shadow: 0 8px 25px var(--shadow-color);
    }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-color), var(--success-color));
      color: white;
      box-shadow: 0 4px 15px rgba(6, 214, 160, 0.3);
    }

    .btn-secondary:hover {
      background: linear-gradient(135deg, var(--success-color), var(--accent-color));
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(6, 214, 160, 0.4);
    }

    /* Scrollbar styling */
    .ai-story-modal::-webkit-scrollbar {
      width: 8px;
    }

    .ai-story-modal::-webkit-scrollbar-track {
      background: rgba(99, 102, 241, 0.1);
      border-radius: 10px;
    }

    .ai-story-modal::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 10px;
    }

    .ai-story-modal::-webkit-scrollbar-thumb:hover {
      background: var(--secondary-color);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .ai-story-modal {
        max-width: 90%;
        margin: 1rem;
      }
      
      .modal-header {
        padding: 1rem;
      }
      
      .story-content {
        padding: 1.5rem;
      }
      
      .modal-footer {
        flex-direction: column;
      }
    }

    /* Glow effects */
    .modal-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
      animation: headerGlow 3s ease-in-out infinite;
    }

    @keyframes headerGlow {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
  `;

        document.head.appendChild(styles);
        document.body.appendChild(eventDiv);
      }

      // Load game data
      async function loadGameData() {
        console.log("Starting to load game data...");

        // Load story data, events with choices, and endings
        console.log("Loading game data...");
        const [storyResponse, eventsWithChoicesResponse, endingsResponse] = await Promise.all([
          fetch("./game_story_data_expanded.json"),
          fetch("./random_events_with_choices.json"),
          fetch("./endings.json"),
        ]);

        console.log("Response status:", {
          story: storyResponse.status,
          eventsWithChoices: eventsWithChoicesResponse.status,
          endings: endingsResponse.status,
        });

        if (storyResponse.ok && eventsWithChoicesResponse.ok && endingsResponse.ok) {
          gameStoryData = await storyResponse.json();
          randomEventsWithChoicesData = await eventsWithChoicesResponse.json();
          const endingsJson = await endingsResponse.json();
          endingsData = endingsJson.endings || endingsJson;

          console.log("‚úÖ Game data loaded successfully:", {
            scenarios: gameStoryData.length,
            randomEventsWithChoices: randomEventsWithChoicesData.length,
            endings: endingsData.length,
          });
          updateScenarioCounter();
          return; // Success, exit function
        } else {
          throw new Error(
            `HTTP Error: ${storyResponse.status}, ${eventsWithChoicesResponse.status}, ${endingsResponse.status}`
          );
        }
      }

      // Preload next stories for better performance
      function preloadNextStories() {
        if (gameState.currentTurn < maxTurns - 2) {
          const nextTurns = [gameState.currentTurn + 1, gameState.currentTurn + 2];

          nextTurns.forEach((turn) => {
            const cacheKey = `turn_${turn}_${gameState.usedScenarios.length}`;
            if (!storyCache.has(cacheKey) && gameStoryData.length > 0) {
              const usedSet = new Set(gameState.usedScenarios);
              const availableStories = gameStoryData.filter((story) => !usedSet.has(story.id));

              if (availableStories.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableStories.length);
                const story = availableStories[randomIndex];
                storyCache.set(cacheKey, story);
              }
            }
          });
        }
      }

      // Handle keyboard inputs
      function handleKeyPress(e) {
        if (gameState.gameEnded) return;

        // Space or Enter to continue/select first choice
        if ((e.code === "Space" || e.code === "Enter") && !isProcessingChoice) {
          const firstChoice = document.querySelector(".choice:not(.disabled)");
          if (firstChoice) {
            const choiceData = JSON.parse(firstChoice.dataset.choice);
            const index = parseInt(firstChoice.dataset.choiceIndex);
            makeChoice(choiceData, index);
          }
        }

        // Number keys 1-9 to select choices
        if (e.code.startsWith("Digit") && !isProcessingChoice) {
          const num = parseInt(e.code.replace("Digit", "")) - 1;
          const choices = document.querySelectorAll(".choice:not(.disabled)");
          if (choices[num]) {
            const choiceData = JSON.parse(choices[num].dataset.choice);
            const index = parseInt(choices[num].dataset.choiceIndex);
            makeChoice(choiceData, index);
          }
        }
      }

      // Update scenario counter display
      function updateScenarioCounter() {
        const counter = document.getElementById("scenarioCount");
        if (counter) {
          counter.textContent = gameStoryData.length;

          // Change color based on data completeness
          const scenarioCounterEl = counter.parentElement;
          if (gameStoryData.length >= 20) {
            scenarioCounterEl.style.color = "#4CAF50"; // Green for complete
          } else if (gameStoryData.length >= 10) {
            scenarioCounterEl.style.color = "#FF9800"; // Orange for partial
          } else {
            scenarioCounterEl.style.color = "#F44336"; // Red for minimal
          }
        }
      }

      // Reload game data function
      async function reloadGameData() {
        const btn = document.getElementById("reloadDataBtn");
        const originalText = btn.innerHTML;
        btn.innerHTML = "‚è≥ ƒêang t·∫£i...";
        btn.disabled = true;

        try {
          await loadGameData();
          // Show success message
          btn.innerHTML = "‚úÖ ƒê√£ t·∫£i!";
          console.log("Game data reloaded successfully!");

          // Show notification to user
          const notification = document.createElement("div");
          notification.style.cssText = `
            position: fixed; top: 20px; right: 20px; 
            background: #4CAF50; color: white; 
            padding: 12px 20px; border-radius: 6px; 
            z-index: 1000; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
          `;
          notification.textContent = `‚úÖ ƒê√£ t·∫£i ${gameStoryData.length} t√¨nh hu·ªëng game!`;
          document.body.appendChild(notification);

          setTimeout(() => {
            notification.remove();
          }, 3000);
        } catch (error) {
          btn.innerHTML = "‚ùå L·ªói!";
          console.error("Failed to reload game data:", error);
        }

        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.disabled = false;
        }, 2000);
      }

      // Initialize game
      function startGame() {
        console.log("üéÆ Starting game...");

        // Ch·ªâ setup gameState n·∫øu ch∆∞a c√≥ ho·∫∑c ch∆∞a ƒë∆∞·ª£c setup t·ª´ difficulty selection
        if (!gameState || !gameState.stats.hasOwnProperty("economy")) {
          console.log("‚ö†Ô∏è No valid gameState found, creating default...");
          gameState = {
            currentTurn: 1,
            usedScenarios: [],
            stats: {
              discontent: 50,
              conflict: 50,
              economy: 50,
              environment: 50,
              freedom: 50,
              security: 50,
            },
            score: 0,
          };
        } else {
          console.log("‚úÖ Using existing gameState from difficulty selection:", gameState);
        }

        console.log("üéØ Current game stats:", gameState.stats);

        // Remove document event listeners first to prevent memory leaks
        window.removeEventListener("keydown", handleKeyPress);

        loadGameData()
          .then(() => {
            console.log("üìö Game data loaded, starting UI...");

            // ·∫®n start screen v√† hi·ªÉn th·ªã game
            document.getElementById("startScreen").classList.add("hidden");
            document.getElementById("gameContainer").style.display = "block";
            document.getElementById("guideBtn").style.display = "block";

            console.log("üéØ Updating display with stats:", gameState.stats);
            updateDisplay();
            console.log("üîÑ Loading first story...");
            loadCurrentStory();
          })
          .catch((error) => {
            console.error("‚ùå Error starting game:", error);
            alert("L·ªói kh·ªüi ƒë·ªông game: " + error.message);
          });
      }

      // Update stats display with visual effects
      function updateStatsDisplay() {
        const statsPanel = document.getElementById("statsPanel");
        if (!statsPanel) return;

        Object.entries(gameState.stats).forEach(([stat, value]) => {
          // Check if stat element already exists
          let statElement = document.getElementById(`stat-${stat}`);
          const isNewElement = !statElement;

          if (isNewElement) {
            statElement = document.createElement("div");
            statElement.className = "stat";
            statElement.id = `stat-${stat}`;
            statsPanel.appendChild(statElement);
          }

          // Detect value changes for animation
          const oldValue = parseInt(statElement.dataset.oldValue) || value;
          const hasChanged = oldValue !== value;

          // Determine status class
          let statusClass = "";
          if (stat === "discontent" || stat === "conflict") {
            // Higher is worse for these stats
            if (value >= 70) statusClass = "critical";
            else if (value >= 50) statusClass = "warning";
            else statusClass = "good";
          } else {
            // Higher is better for these stats
            if (value <= 20) statusClass = "critical";
            else if (value <= 40) statusClass = "warning";
            else if (value >= 70) statusClass = "good";
          }

          // Color coding based on stat type and value
          let fillColor = "#4caf50"; // Default green
          if (stat === "discontent" || stat === "conflict") {
            fillColor = value >= 70 ? "#ff4444" : value >= 50 ? "#ffaa00" : "#4caf50";
          } else {
            fillColor = value >= 60 ? "#4caf50" : value >= 40 ? "#ffaa00" : "#ff4444";
          }

          // Update classes
          statElement.className = `stat ${statusClass}`;

          // Create change indicator if value changed
          let changeIndicator = "";
          if (hasChanged && !isNewElement) {
            const change = value - oldValue;
            const changeClass = change > 0 ? "" : "negative";
            changeIndicator = `<div class="stat-change ${changeClass}">${change > 0 ? "+" + change : change}</div>`;
          }

          statElement.innerHTML = `
            <div class="stat-label">${statLabels[stat]}</div>
            <div class="stat-value ${hasChanged ? "changed" : ""} ${
            value > oldValue ? "increased" : value < oldValue ? "decreased" : ""
          }" 
                 id="stat-value-${stat}" style="color: ${fillColor}">${value}</div>
            <div class="stat-bar">
              <div class="stat-fill" style="width: ${Math.max(
                0,
                Math.min(100, value)
              )}%; background: ${fillColor}"></div>
            </div>
            ${changeIndicator}
          `;

          // Store current value for next comparison
          statElement.dataset.oldValue = value;

          // Remove animation classes after animation completes
          if (hasChanged) {
            setTimeout(() => {
              const valueEl = document.getElementById(`stat-value-${stat}`);
              if (valueEl) {
                valueEl.classList.remove("changed", "increased", "decreased");
              }
              const changeEl = statElement.querySelector(".stat-change");
              if (changeEl) changeEl.remove();
            }, 2000);
          }
        });

        // Check for crisis situations
        checkCrisisSituations();
      }

      // Check and display crisis alerts
      function checkCrisisSituations() {
        const criticalStats = [];

        Object.entries(gameState.stats).forEach(([stat, value]) => {
          if (stat === "discontent" || stat === "conflict") {
            if (value >= 85) criticalStats.push(statLabels[stat]);
          } else {
            if (value <= 15) criticalStats.push(statLabels[stat]);
          }
        });

        if (criticalStats.length > 0) {
          const message = `KH·ª¶NG HO·∫¢NG: ${criticalStats.join(", ")} ƒëang ·ªü m·ª©c nguy hi·ªÉm!`;
          showCrisisAlert(message);
        }

        // Check for multiple problematic stats
        const problematicStats = Object.entries(gameState.stats).filter(([stat, value]) => {
          if (stat === "discontent" || stat === "conflict") {
            return value >= 70;
          } else {
            return value <= 30;
          }
        });

        if (problematicStats.length >= 3) {
          showCrisisAlert("C·∫¢NH B√ÅO: Nhi·ªÅu ch·ªâ s·ªë ƒëang ·ªü m·ª©c c√≥ v·∫•n ƒë·ªÅ!");
        }
      }

      // Show crisis alert
      function showCrisisAlert(message) {
        // Remove existing alert if any
        const existingAlert = document.querySelector(".crisis-alert");
        if (existingAlert) existingAlert.remove();

        const alertDiv = document.createElement("div");
        alertDiv.className = "crisis-alert";
        alertDiv.textContent = "‚ö†Ô∏è " + message;
        alertDiv.style.display = "block";

        document.body.appendChild(alertDiv);

        setTimeout(() => {
          if (alertDiv.parentNode) {
            alertDiv.remove();
          }
        }, 4000);
      }

      // Update turn and score with late game warning
      function updateGameInfo() {
        const turnElement = document.getElementById("turnCounter");
        const scoreElement = document.getElementById("gameScore");

        if (turnElement) {
          turnElement.textContent = gameState.currentTurn + "/" + maxTurns;

          // Add late game warning
          const gameProgress = gameState.currentTurn / maxTurns;
          if (gameProgress >= 0.75) {
            turnElement.classList.add("late-game");
          } else {
            turnElement.classList.remove("late-game");
          }
        }

        if (scoreElement) {
          scoreElement.textContent = gameState.score;
        }
      }

      // OPTIMIZED: Load current story function with caching and performance improvements
      let storyCache = new Map();
      let isLoadingStory = false;

      function loadCurrentStory() {
        // Prevent multiple simultaneous loads
        if (isLoadingStory) return;
        isLoadingStory = true;

        // Show loading state
        const storySection = document.querySelector(".story-section");
        storySection?.classList.add("loading");

        // Use requestAnimationFrame for smooth UI updates
        requestAnimationFrame(() => {
          console.log(`‚ö° Loading story for turn ${gameState.currentTurn}/${maxTurns}`);

          // Check cache first
          const cacheKey = `turn_${gameState.currentTurn}_${gameState.usedScenarios.length}`;
          let storyData = storyCache.get(cacheKey);

          if (!storyData) {
            // Get available scenarios that haven't been used (optimized with Set)
            const usedSet = new Set(gameState.usedScenarios);
            const availableScenarios = gameStoryData.filter((scenario) => !usedSet.has(scenario.id));

            if (availableScenarios.length > 0) {
              // Use a random available scenario
              const randomIndex = Math.floor(Math.random() * availableScenarios.length);
              storyData = availableScenarios[randomIndex];
              gameState.usedScenarios.push(storyData.id);
              console.log(`‚úÖ Selected scenario: ${storyData.title} (ID: ${storyData.id})`);
            } else {
              // All scenarios used, reset and start over
              if (gameStoryData.length > 0) {
                console.log("üîÑ All scenarios used, resetting used scenarios list");
                gameState.usedScenarios = [];
                storyData = gameStoryData[Math.floor(Math.random() * gameStoryData.length)];
                gameState.usedScenarios.push(storyData.id);
              } else {
                // Fallback scenario
                storyData = {
                  id: 999,
                  title: "Quy·∫øt ƒê·ªãnh Quan Tr·ªçng",
                  description:
                    "M·ªôt t√¨nh hu·ªëng quan tr·ªçng ƒëang ch·ªù quy·∫øt ƒë·ªãnh c·ªßa b·∫°n. H√£y c√¢n nh·∫Øc k·ªπ l∆∞·ª°ng tr∆∞·ªõc khi h√†nh ƒë·ªông.",
                  choices: [
                    {
                      title: "L·ª±a ch·ªçn th·∫≠n tr·ªçng",
                      text: "H√†nh ƒë·ªông m·ªôt c√°ch c·∫©n th·∫≠n v√† th·∫≠n tr·ªçng ƒë·ªÉ tr√°nh r·ªßi ro",
                      effects: { discontent: -5, security: 5, conflict: -3 },
                    },
                    {
                      title: "H√†nh ƒë·ªông m·∫°nh m·∫Ω",
                      text: "ƒê∆∞a ra quy·∫øt ƒë·ªãnh quy·∫øt ƒëo√°n v√† m·∫°nh m·∫Ω ƒë·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ",
                      effects: { conflict: -5, freedom: -5, security: 10 },
                    },
                  ],
                };
              }
            }

            // Cache the story for potential reuse
            storyCache.set(cacheKey, storyData);
          }

          // Display the story with smooth animation
          const titleEl = document.getElementById("storyTitle");
          const textEl = document.getElementById("storyText");

          if (titleEl) titleEl.textContent = storyData.title;
          if (textEl) textEl.textContent = storyData.description;

          displayChoices(storyData.choices);

          // Remove loading state
          setTimeout(() => {
            storySection?.classList.remove("loading");
            isLoadingStory = false;

            // Preload next stories for better performance
            preloadNextStories();
          }, 100);
        });
      }

      // OPTIMIZED: Display choices with highlighting for high impact
      function displayChoices(choices) {
        const choicesGrid = document.getElementById("choicesGrid");
        if (!choicesGrid) return;

        // Ensure we have at least 1 choice
        if (!choices || choices.length === 0) {
          choices = [
            {
              title: "Ti·∫øp t·ª•c",
              text: "Chuy·ªÉn sang l∆∞·ª£t ti·∫øp theo",
              effects: { discontent: 0 },
            },
          ];
        }

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();

        choices.forEach((choice, index) => {
          const choiceElement = document.createElement("div");
          let choiceClass = "choice";

          // Check if this is a high impact choice
          const isHighImpact = checkHighImpact(choice.effects);
          if (isHighImpact) {
            choiceClass += " high-impact";
          }

          choiceElement.className = choiceClass;

          // Use event delegation instead of individual onclick handlers
          choiceElement.dataset.choiceIndex = index;
          choiceElement.dataset.choice = JSON.stringify(choice);

          // Create effects preview with enhanced formatting
          let effectsPreview = "";
          if (choice.effects) {
            Object.entries(choice.effects).forEach(([stat, change]) => {
              if (change !== 0) {
                const sign = change > 0 ? "+" : "";
                const statName = statLabels[stat] || stat;
                const impactClass = Math.abs(change) >= 15 ? " high-impact-effect" : "";
                effectsPreview += `<span class="effect-item${impactClass}">${statName} ${sign}${change}</span> `;
              }
            });
          }

          choiceElement.innerHTML = `
            <div class="choice-title">${choice.title}</div>
            <div class="choice-text">${choice.text}</div>
            <div class="choice-effects">T√°c ƒë·ªông: ${effectsPreview || "Kh√¥ng c√≥"}</div>
          `;

          fragment.appendChild(choiceElement);
        });

        // Clear and append all choices at once for better performance
        choicesGrid.innerHTML = "";
        choicesGrid.appendChild(fragment);

        // Add event delegation listener if not already added
        if (!choicesGrid.hasAttribute("data-listener-added")) {
          choicesGrid.addEventListener("click", function (e) {
            const choiceEl = e.target.closest(".choice");
            if (choiceEl && !choiceEl.classList.contains("disabled")) {
              const choice = JSON.parse(choiceEl.dataset.choice);
              const index = parseInt(choiceEl.dataset.choiceIndex);
              makeChoice(choice, index);
            }
          });
          choicesGrid.setAttribute("data-listener-added", "true");
        }
      }

      // Check if a choice has high impact effects
      function checkHighImpact(effects) {
        if (!effects) return false;

        // Consider high impact if any effect is >= 15 or <= -15
        return Object.values(effects).some((value) => Math.abs(value) >= 15);
      }

      // OPTIMIZED: Make choice with debouncing and faster processing
      let isProcessingChoice = false;

      function makeChoice(choice, index) {
        // Prevent double-clicking with debouncing
        if (isProcessingChoice) return;
        isProcessingChoice = true;

        console.log(`‚ö° Making choice at turn ${gameState.currentTurn}:`, choice.title);

        // Check for emergency endings (negative conditions)
        const emergencyEndingConditions = {
          discontent: gameState.stats.discontent >= 90,
          conflict: gameState.stats.conflict >= 90,
          economy: gameState.stats.economy <= 10,
        };

        const shouldTriggerEmergencyEnding = Object.values(emergencyEndingConditions).some((condition) => condition);

        // Only check for endings if it's the last turn or emergency conditions are met
        const isLastTurn = gameState.currentTurn >= maxTurns;
        if (shouldTriggerEmergencyEnding || isLastTurn) {
          const endingToShow = findAppropriateEnding();
          if (endingToShow) {
            gameState.gameEnded = true;
            showEnding(endingToShow);
            return;
          }
        }

        // Continue with normal turn if no ending triggered

        // Check if it's time to generate AI story (every 5 turns)
        if (gameState.currentTurn % 5 === 0) {
          console.log("start story");
          generateAIStory();
        }

        // Disable all choices immediately to prevent double-clicks
        const allChoices = document.querySelectorAll(".choice");
        allChoices.forEach((el) => {
          el.classList.add("disabled");
        });

        // Use requestAnimationFrame for smooth processing
        requestAnimationFrame(() => {
          // Apply difficulty modifiers
          const modifiedEffects = applyDifficultyModifiers(choice.effects || {});
          console.log("Modified effects:", modifiedEffects);

          // Apply effects with optimized loop
          let totalChange = 0;
          for (const [stat, change] of Object.entries(modifiedEffects)) {
            if (gameState.stats.hasOwnProperty(stat)) {
              const oldValue = gameState.stats[stat];
              gameState.stats[stat] = Math.max(0, Math.min(100, gameState.stats[stat] + change));
              console.log(`üìà ${stat}: ${oldValue} -> ${gameState.stats[stat]} (${change > 0 ? "+" : ""}${change})`);
              totalChange += Math.abs(change);
            }
          }

          // Update score
          gameState.score += totalChange;
          console.log(`üéØ Score updated: +${totalChange}, Total: ${gameState.score}`);

          // Update display immediately to show changes
          updateDisplay();
          console.log("üîÑ Display updated with new stats");

          // Check for game end conditions
          if (checkGameEnd()) {
            isProcessingChoice = false;
            return;
          }

          // Next turn
          gameState.currentTurn++;

          // Random event chance based on difficulty with cooldown
          const mode = DIFFICULTY_MODES[currentDifficulty];
          const eventChance = Math.random();
          const turnsSinceLastEvent = gameState.currentTurn - lastEventTurn;

          console.log(
            `üé≤ Event check: roll=${eventChance.toFixed(2)} vs ${
              mode.randomEventsFrequency
            }, cooldown=${turnsSinceLastEvent}/${eventCooldown}`
          );

          setTimeout(() => {
            // Only trigger if conditions met: min turn, cooldown passed AND chance hits
            const canTriggerEvent = turnsSinceLastEvent >= eventCooldown && gameState.currentTurn >= minEventTurn;
            const shouldTriggerEvent = eventChance < mode.randomEventsFrequency;

            if (canTriggerEvent && shouldTriggerEvent && randomEventsWithChoicesData.length > 0) {
              console.log("üé™ Triggering random event!");
              lastEventTurn = gameState.currentTurn;
              triggerRandomEvent();
              setTimeout(() => {
                loadCurrentStory();
                isProcessingChoice = false;
              }, 3000);
            } else {
              console.log(`üìñ No event: cooldown=${canTriggerEvent}, chance=${shouldTriggerEvent}`);
              loadCurrentStory();
              isProcessingChoice = false;
            }
          }, 800);
        });
      }

      // Trigger random event - now supports both types of events
      function triggerRandomEvent() {
        console.log("üé™ triggerRandomEvent called...");

        const event = selectRandomEventWithChoices();
        if (event) {
          console.log(`üé≤ Random event selected: ${event.title}`);
          showRandomEventWithChoices(event);
        } else {
          console.log("üö´ No random events available for current conditions");
        }
      }
      function checkEventConditions(event) {
        if (!event.conditions) return true;

        // Check min_turn
        if (event.conditions.min_turn && gameState.currentTurn < event.conditions.min_turn) {
          return false;
        }

        // Check m·ªói stat condition
        for (let stat in event.conditions) {
          if (stat === "min_turn") continue;

          let condition = event.conditions[stat];
          let currentValue = gameState.stats[stat];

          // Check min condition
          if (condition.min && currentValue < condition.min) {
            return false;
          }

          // Check max condition
          if (condition.max && currentValue > condition.max) {
            return false;
          }
        }

        return true;
      }
      // Select random event with choices
      function selectRandomEventWithChoices() {
        console.log("üîç Selecting random event with choices from", randomEventsWithChoicesData?.length || 0, "events");
        if (!randomEventsWithChoicesData || randomEventsWithChoicesData.length === 0) {
          console.log("‚ùå No random events with choices data available");
          return null;
        }

        // Filter events that meet conditions AND haven't been used recently
        const availableEvents = randomEventsWithChoicesData.filter((event) => {
          // Skip if event was used recently
          if (usedEvents.has(event.title)) {
            console.log(`‚è≠Ô∏è Skipping used event: ${event.title}`);
            return false;
          }

          // Check basic conditions
          const meetsConditions = checkEventConditions(event);
          console.log(`üìã Event with choices "${event.title}" meets conditions:`, meetsConditions);

          if (!meetsConditions) return false;

          // For conditional events, check trigger_chance
          if (event.rarity === "conditional") {
            const triggerRoll = Math.random() < event.trigger_chance;
            console.log(`üé≤ Conditional event with choices roll: ${triggerRoll}`);
            return triggerRoll;
          }

          return true;
        });

        console.log("‚úÖ Available events with choices after filtering:", availableEvents.length);
        if (availableEvents.length === 0) {
          console.log("‚ö†Ô∏è No events with choices available for current conditions");
          return null;
        }

        // Select random from available and mark as used
        const selectedEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
        usedEvents.add(selectedEvent.title);
        console.log("üéØ Selected event with choices:", selectedEvent.title, "| Used events:", usedEvents.size);
        return selectedEvent;
      }

      // Show random event in center screen
      function showRandomEvent(event) {
        if (!event) return;

        console.log(`üé™ Showing random event: ${event.title}`);

        // Apply effects with difficulty modifiers
        const modifiedEffects = applyDifficultyModifiers(event.effects || {});
        let totalChange = 0;

        // Apply effects to game state first
        Object.entries(modifiedEffects).forEach(([stat, change]) => {
          if (change !== 0) {
            const oldValue = gameState.stats[stat];
            gameState.stats[stat] = Math.max(0, Math.min(100, gameState.stats[stat] + change));
            totalChange += Math.abs(change);
            console.log(
              `Random event effect - ${stat}: ${oldValue} -> ${gameState.stats[stat]} (${
                change > 0 ? "+" : ""
              }${change})`
            );
          }
        });

        // Update score
        gameState.score += totalChange * 2; // Random events give bonus score

        // Create event popup in center screen
        const eventDiv = document.createElement("div");
        eventDiv.className = "random-event-popup";
        eventDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #1a1a2e, #16213e);
          color: white;
          padding: 35px;
          border-radius: 25px;
          border: 3px solid #f59e0b;
          max-width: 700px;
          z-index: 10000;
          box-shadow: 0 25px 60px rgba(0,0,0,0.8), 0 0 40px rgba(245, 158, 11, 0.3);
          animation: eventSlideIn 0.8s cubic-bezier(0.4, 0, 0.2, 1);
          backdrop-filter: blur(15px);
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
        `;

        // Determine event severity
        const isHighImpact = Object.values(modifiedEffects).some((val) => Math.abs(val) >= 15);
        const severityColor = isHighImpact ? "#ef4444" : "#f59e0b";
        const severityIcon = isHighImpact ? "üí•" : "‚ö°";

        eventDiv.innerHTML = `
          <div style="text-align: center; margin-bottom: 25px;">
            <h2 style="color: ${severityColor}; margin-bottom: 10px; font-size: 1.8em; animation: eventTitleGlow 2s infinite;">
              ${severityIcon} RANDOM EVENT! ${severityIcon}
            </h2>
            <div style="background: rgba(245, 158, 11, 0.15); padding: 8px 16px; border-radius: 20px; display: inline-block; font-size: 0.9em; color: #f59e0b; border: 1px solid rgba(245, 158, 11, 0.3);">
              L∆∞·ª£t ${gameState.currentTurn} | ${event.rarity?.toUpperCase() || "RANDOM"}
            </div>
          </div>
          
          <h3 style="color: #f59e0b; margin-bottom: 20px; text-align: center; font-size: 1.6em; line-height: 1.2;">
            ${event.title}
          </h3>
          
          <p style="margin-bottom: 30px; line-height: 1.7; text-align: center; font-size: 1.15em; color: #e2e8f0; padding: 0 10px;">
            ${event.text}
          </p>
          
          <div style="background: rgba(99, 102, 241, 0.15); padding: 25px; border-radius: 15px; margin-bottom: 30px; border: 1px solid rgba(99, 102, 241, 0.3);">
            <h4 style="color: #6366f1; margin-bottom: 20px; text-align: center; font-size: 1.2em;">üìä T√°c ƒê·ªông L√™n Ch·ªâ S·ªë:</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
              ${Object.entries(modifiedEffects)
                .map(([stat, change]) => {
                  if (change === 0) return "";
                  return `<span style="
                  display: inline-block; 
                  padding: 10px 15px; 
                  background: ${change > 0 ? "rgba(239, 68, 68, 0.2)" : "rgba(16, 185, 129, 0.2)"}; 
                  border: 2px solid ${change > 0 ? "#ef4444" : "#10b981"};
                  border-radius: 25px; 
                  color: ${change > 0 ? "#ef4444" : "#10b981"};
                  font-weight: 700;
                  font-size: 1em;
                  ${
                    Math.abs(change) >= 15
                      ? "animation: highImpactEffect 2s infinite; box-shadow: 0 0 15px rgba(255,255,255,0.2);"
                      : ""
                  }
                ">
                  ${statLabels[stat] || stat}: ${change > 0 ? "+" : ""}${change}
                </span>`;
                })
                .filter(Boolean)
                .join("")}
            </div>
          </div>
          
          <div style="text-align: center;">
            <button onclick="closeRandomEvent(this)" 
                    style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; padding: 18px 40px; border-radius: 30px; cursor: pointer; font-weight: 700; font-size: 1.2em; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px;">
              ‚ö° Ti·∫øp T·ª•c Game
            </button>
          </div>
        `;

        // Add to body
        document.body.appendChild(eventDiv);

        // Update display
        updateDisplay();

        // Add close function
        window.closeRandomEvent = function (button) {
          const eventPopup = button.closest(".random-event-popup");
          eventPopup.style.animation = "eventSlideOut 0.5s ease-in";
          setTimeout(() => {
            if (eventPopup.parentNode) {
              eventPopup.remove();
            }
            delete window.closeRandomEvent;
          }, 500);
        };

        // Add hover effect to button
        const continueBtn = eventDiv.querySelector("button");
        continueBtn.addEventListener("mouseenter", function () {
          this.style.transform = "scale(1.05) translateY(-2px)";
          this.style.boxShadow = "0 10px 30px rgba(245, 158, 11, 0.5)";
        });
        continueBtn.addEventListener("mouseleave", function () {
          this.style.transform = "scale(1) translateY(0)";
          this.style.boxShadow = "none";
        });

        // Update stats display after applying effects
        updateStatsDisplay();

        // Auto-hide after 5 seconds
        setTimeout(() => {
          randomEventEl.style.display = "none";
        }, 5000);
      }

      // Show random event with choices
      function showRandomEventWithChoices(event) {
        if (!event) return;

        console.log(`üé™ Showing random event with choices: ${event.title}`);

        // Create event popup in center screen with choices
        const eventDiv = document.createElement("div");
        eventDiv.className = "random-event-popup";
        eventDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #1a1a2e, #16213e);
          color: white;
          padding: 35px;
          border-radius: 25px;
          border: 3px solid #f59e0b;
          max-width: 800px;
          z-index: 10000;
          box-shadow: 0 25px 60px rgba(0,0,0,0.8), 0 0 40px rgba(245, 158, 11, 0.3);
          animation: eventSlideIn 0.8s cubic-bezier(0.4, 0, 0.2, 1);
          backdrop-filter: blur(15px);
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
        `;

        // Determine event severity
        const isHighImpact = event.choices.some((choice) =>
          Object.values(choice.effects).some((val) => Math.abs(val) >= 15)
        );
        const severityColor = isHighImpact ? "#ef4444" : "#f59e0b";
        const severityIcon = isHighImpact ? "üí•" : "‚ö°";

        eventDiv.innerHTML = `
          <div style="text-align: center; margin-bottom: 25px;">
            <h2 style="color: ${severityColor}; margin-bottom: 10px; font-size: 1.8em; animation: eventTitleGlow 2s infinite;">
              ${severityIcon} RANDOM EVENT WITH CHOICES! ${severityIcon}
            </h2>
            <div style="background: rgba(245, 158, 11, 0.15); padding: 8px 16px; border-radius: 20px; display: inline-block; font-size: 0.9em; color: #f59e0b; border: 1px solid rgba(245, 158, 11, 0.3);">
              L∆∞·ª£t ${gameState.currentTurn} | ${event.rarity?.toUpperCase() || "RANDOM"}
            </div>
          </div>
          
          <h3 style="color: #f59e0b; margin-bottom: 20px; text-align: center; font-size: 1.6em; line-height: 1.2;">
            ${event.title}
          </h3>
          
          <p style="margin-bottom: 30px; line-height: 1.7; text-align: center; font-size: 1.15em; color: #e2e8f0; padding: 0 10px;">
            ${event.text}
          </p>
          
          <div style="margin-bottom: 30px;">
            <h4 style="color: #6366f1; margin-bottom: 20px; text-align: center; font-size: 1.2em;">üìã L·ª±a Ch·ªçn C·ªßa B·∫°n:</h4>
            <div class="choices-container" style="display: flex; flex-direction: column; gap: 15px;">
              ${event.choices
                .map((choice, index) => {
                  const isHighImpactChoice = Object.values(choice.effects).some((val) => Math.abs(val) >= 15);
                  const choiceClass = isHighImpactChoice ? "high-impact-choice" : "";

                  let effectsPreview = "";
                  if (choice.effects) {
                    Object.entries(choice.effects).forEach(([stat, change]) => {
                      if (change !== 0) {
                        const sign = change > 0 ? "+" : "";
                        const statName = statLabels[stat] || stat;
                        const impactClass = Math.abs(change) >= 15 ? " high-impact-effect" : "";
                        effectsPreview += `<span class="effect-item${impactClass}">${statName} ${sign}${change}</span> `;
                      }
                    });
                  }

                  return `
                  <div class="choice-option ${choiceClass}" onclick="handleEventChoice(${event.id}, ${index})" 
                       style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%); 
                              padding: 20px; border-radius: 15px; border: 2px solid rgba(99, 102, 241, 0.3); 
                              cursor: pointer; transition: all 0.3s ease; ${
                                isHighImpactChoice
                                  ? "border-color: #ef4444; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);"
                                  : ""
                              }">
                    <div style="font-weight: 700; font-size: 1.1em; margin-bottom: 10px; color: ${
                      isHighImpactChoice ? "#ef4444" : "#f59e0b"
                    };">${choice.title}</div>
                    <div style="margin-bottom: 15px; color: #e2e8f0;">${choice.text}</div>
                    <div style="font-size: 0.9em; color: #cbd5e1;">T√°c ƒë·ªông: ${effectsPreview || "Kh√¥ng c√≥"}</div>
                  </div>
                `;
                })
                .join("")}
            </div>
          </div>
        `;

        // Add to body
        document.body.appendChild(eventDiv);

        // Add hover effects to choices
        const choiceOptions = eventDiv.querySelectorAll(".choice-option");
        choiceOptions.forEach((option) => {
          option.addEventListener("mouseenter", function () {
            this.style.transform = "translateY(-3px) scale(1.02)";
            this.style.boxShadow = "0 8px 25px rgba(99, 102, 241, 0.3)";
          });
          option.addEventListener("mouseleave", function () {
            this.style.transform = "translateY(0) scale(1)";
            this.style.boxShadow = "none";
          });
        });

        // Add global function to handle choice selection
        window.handleEventChoice = function (eventId, choiceIndex) {
          const selectedEvent = randomEventsWithChoicesData.find((e) => e.id === eventId);
          if (!selectedEvent) return;

          const selectedChoice = selectedEvent.choices[choiceIndex];
          console.log(`üéØ Selected choice for event ${eventId}: ${selectedChoice.title}`);

          // Apply effects with difficulty modifiers
          const modifiedEffects = applyDifficultyModifiers(selectedChoice.effects || {});
          let totalChange = 0;

          // Apply effects to game state
          Object.entries(modifiedEffects).forEach(([stat, change]) => {
            if (change !== 0) {
              const oldValue = gameState.stats[stat];
              gameState.stats[stat] = Math.max(0, Math.min(100, gameState.stats[stat] + change));
              totalChange += Math.abs(change);
              console.log(
                `Event choice effect - ${stat}: ${oldValue} -> ${gameState.stats[stat]} (${
                  change > 0 ? "+" : ""
                }${change})`
              );
            }
          });

          // Update score
          gameState.score += totalChange * 2; // Events with choices give bonus score

          // Update display
          updateDisplay();

          // Remove event popup
          const eventPopup = document.querySelector(".random-event-popup");
          if (eventPopup) eventPopup.remove();

          // Clean up global function
          delete window.handleEventChoice;

          // Continue with next turn
          setTimeout(() => {
            loadCurrentStory();
          }, 1000);
        };
      }

      // Function ƒë·ªÉ ƒë√°nh gi√° ending theo requirements t·ª´ endings.json
      function evaluateEnding(ending) {
        if (!ending.requirements) return false;

        const stats = gameState.stats;
        const req = ending.requirements;

        console.log(`üéØ Evaluating ending: ${ending.id}`, {
          currentStats: stats,
          requirements: req,
        });

        // Check basic stat requirements
        for (const [statName, condition] of Object.entries(req)) {
          // Special cases first
          if (statName === "min_turn") {
            const minTurn = parseInt(condition.replace(/[‚â•\s]/g, ""));
            if (gameState.currentTurn < minTurn) {
              console.log(`‚ùå Failed min_turn: ${gameState.currentTurn} < ${minTurn}`);
              return false;
            }
            continue;
          }

          if (statName === "completed_turns") {
            if (condition === "= max_turns") {
              if (gameState.currentTurn <= maxTurns) {
                // Fixed: should be <= not <
                console.log(`‚ùå Failed completed_turns: ${gameState.currentTurn} <= ${maxTurns}`);
                return false;
              }
            }
            continue;
          }

          if (statName === "triggered_by") {
            // Check if the required ending has been triggered
            if (!triggeredEndings.has(condition)) {
              console.log(`‚ùå Failed triggered_by: ${condition} not triggered yet`);
              return false;
            }
            continue;
          }

          // Regular stat checks
          const currentValue = stats[statName];
          if (currentValue === undefined) {
            console.log(`‚ùå Stat not found: ${statName}`);
            return false; // Changed: return false instead of continue
          }

          // Parse condition more carefully
          let passed = false;
          const conditionStr = String(condition).trim();

          if (conditionStr.includes("‚â§")) {
            const threshold = parseInt(conditionStr.replace(/[‚â§\s]/g, ""));
            passed = currentValue <= threshold;
            console.log(`üìä ${statName}: ${currentValue} ‚â§ ${threshold} = ${passed}`);
          } else if (conditionStr.includes("‚â•")) {
            const threshold = parseInt(conditionStr.replace(/[‚â•\s]/g, ""));
            passed = currentValue >= threshold;
            console.log(`üìä ${statName}: ${currentValue} ‚â• ${threshold} = ${passed}`);
          } else {
            // Fallback: try to parse as number for exact match
            const exactValue = parseInt(conditionStr);
            if (!isNaN(exactValue)) {
              passed = currentValue === exactValue;
              console.log(`üìä ${statName}: ${currentValue} === ${exactValue} = ${passed}`);
            } else {
              console.log(`‚ùå Unknown condition format: ${conditionStr}`);
              return false;
            }
          }

          if (!passed) {
            console.log(`‚ùå Failed requirement: ${statName} ${condition} (current: ${currentValue})`);
            return false;
          }
        }

        console.log(`‚úÖ All requirements met for ending: ${ending.id}`);
        return true;
      }

      // Check game end conditions using endings.json
      function checkGameEnd() {
        console.log("üéØ Checking game end conditions...");
        console.log("üìä Current game state:", {
          turn: gameState.currentTurn,
          maxTurns: maxTurns,
          stats: gameState.stats,
          gameEnded: gameState.gameEnded,
        });

        if (gameState.gameEnded) {
          console.log("üîí Game already ended, skipping checks");
          return true;
        }

        // üö® KI·ªÇM TRA C√ÅC TR∆Ø·ªúNG H·ª¢P C·ª∞C ƒêOAN TR∆Ø·ªöC (∆∞u ti√™n cao nh·∫•t)
        console.log("üö® Checking critical failure conditions first...");

        // C√°ch m·∫°ng - Conflict qu√° cao
        if (gameState.stats.conflict >= 85) {
          console.log("üí• CRITICAL: Conflict >= 85, triggering revolution");
          endGame(
            "revolution",
            "üî• C√ÅCH M·∫†NG B√ôNG N·ªî",
            "Xung ƒë·ªôt x√£ h·ªôi v∆∞·ª£t qu√° ng∆∞·ª°ng ch·ªãu ƒë·ª±ng. H√†ng tri·ªáu ng∆∞·ªùi xu·ªëng ƒë∆∞·ªùng bi·ªÉu t√¨nh. Ch√≠nh ph·ªß c·ªßa b·∫°n ƒë√£ b·ªã l·∫≠t ƒë·ªï b·ªüi s·ª©c m·∫°nh c·ªßa nh√¢n d√¢n!"
          );
          return true;
        }

        // S·ª•p ƒë·ªï kinh t·∫ø - Economy qu√° th·∫•p
        if (gameState.stats.economy <= 10) {
          console.log("üìâ CRITICAL: Economy <= 10, triggering economic collapse");
          endGame(
            "economic_collapse",
            "üìâ SUY THO√ÅI KINH T·∫æ",
            "N·ªÅn kinh t·∫ø s·ª•p ƒë·ªï ho√†n to√†n. ƒê·∫•t n∆∞·ªõc r∆°i v√†o kh·ªßng ho·∫£ng t√†i ch√≠nh nghi√™m tr·ªçng. Th·∫•t nghi·ªáp cao, l·∫°m ph√°t tƒÉng v·ªçt. B·∫°n ƒë√£ th·∫•t b·∫°i trong vi·ªác l√£nh ƒë·∫°o kinh t·∫ø!"
          );
          return true;
        }

        // Th·∫£m h·ªça m√¥i tr∆∞·ªùng - Environment qu√° th·∫•p
        if (gameState.stats.environment <= 10) {
          console.log("üåç CRITICAL: Environment <= 10, triggering environmental disaster");
          endGame(
            "environmental_disaster",
            "üåç TH·∫¢M H·ªåA M√îI TR∆Ø·ªúNG",
            "M√¥i tr∆∞·ªùng b·ªã t√†n ph√° nghi√™m tr·ªçng. Bi·∫øn ƒë·ªïi kh√≠ h·∫≠u v√† √¥ nhi·ªÖm ƒë√£ l√†m ƒë·∫•t n∆∞·ªõc kh√¥ng th·ªÉ sinh s·ªëng ƒë∆∞·ª£c. Th·∫£m h·ªça sinh th√°i ƒë√£ x·∫£y ra!"
          );
          return true;
        }

        // M·∫•t quy·ªÅn l·ª±c - Discontent qu√° cao
        if (gameState.stats.discontent >= 85) {
          console.log("üîª CRITICAL: Discontent >= 85, triggering overthrow");
          endGame(
            "overthrown",
            "üîª M·∫§T QUY·ªÄN L·ª∞C",
            "S·ª± b·∫•t m√£n c·ªßa d√¢n ch√∫ng ƒë·∫°t ƒë·ªânh ƒëi·ªÉm. Ng∆∞·ªùi d√¢n kh√¥ng c√≤n tin t∆∞·ªüng v√†o ch√≠nh quy·ªÅn. B·∫°n b·ªã tru·∫•t ph·∫ø kh·ªèi ch·ª©c v·ª•!"
          );
          return true;
        }

        // Security qu√° th·∫•p - M·∫•t ki·ªÉm so√°t
        if (gameState.stats.security <= 5) {
          console.log("‚ö†Ô∏è CRITICAL: Security <= 5, triggering anarchy");
          endGame(
            "anarchy",
            "‚ö° T√åNH TR·∫†NG V√î CH√çNH PH·ª¶",
            "An ninh s·ª•p ƒë·ªï ho√†n to√†n. T·ªôi ph·∫°m ho√†nh h√†nh, lu·∫≠t ph√°p kh√¥ng c√≤n hi·ªáu l·ª±c. ƒê·∫•t n∆∞·ªõc r∆°i v√†o t√¨nh tr·∫°ng h·ªón lo·∫°n!"
          );
          return true;
        }

        // Freedom qu√° th·∫•p + Security qu√° cao = ƒê·ªôc t√†i ngay l·∫≠p t·ª©c
        if (gameState.stats.freedom <= 5 && gameState.stats.security >= 90) {
          console.log("‚öîÔ∏è CRITICAL: Extreme dictatorship detected");
          endGame(
            "extreme_dictatorship",
            "üëë ƒê·ªòC T√ÄI TUY·ªÜT ƒê·ªêI",
            "B·∫°n ƒë√£ thi·∫øt l·∫≠p ch·∫ø ƒë·ªô ƒë·ªôc t√†i tuy·ªát ƒë·ªëi. M·ªçi quy·ªÅn t·ª± do b·ªã tri·ªát ti√™u, ki·ªÉm so√°t tuy·ªát ƒë·ªëi. Nh∆∞ng l·ªãch s·ª≠ ch·ª©ng minh... kh√¥ng ai cai tr·ªã m√£i m√£i!"
          );
          return true;
        }

        // üìö SAU ƒê√ì M·ªöI KI·ªÇM TRA ENDINGS.JSON (cho c√°c tr∆∞·ªùng h·ª£p b√¨nh th∆∞·ªùng)
        // QUAN TR·ªåNG: Ch·ªâ ki·ªÉm tra endings ƒë·∫∑c bi·ªát sau turn 3 ƒë·ªÉ tr√°nh ending s·ªõm
        if (Array.isArray(endingsData) && endingsData.length > 0 && gameState.currentTurn >= 3) {
          console.log(`üìö Evaluating ${endingsData.length} endings from endings.json (turn ${gameState.currentTurn})`);

          // Evaluate each ending in order from most specific to generic
          for (const ending of endingsData) {
            if (triggeredEndings.has(ending.id)) continue; // Skip already shown endings

            // Filter out premature endings - some endings should only trigger after certain turns
            const earlyEndingIds = ["dictator_temporary", "authoritarian_stability", "talented_leader"];
            if (earlyEndingIds.includes(ending.id) && gameState.currentTurn < 5) {
              console.log(`‚è∞ Skipping early ending ${ending.id} (turn ${gameState.currentTurn} < 5)`);
              continue;
            }

            if (evaluateEnding(ending)) {
              // Handle leads_to chain for dictator path
              if (ending.leads_to) {
                console.log(`ÔøΩ Chain ending detected: ${ending.id} ‚Üí ${ending.leads_to}`);

                // Trigger temporary ending first (if defined) then queue leads_to
                endGame(ending.id, ending.name, ending.description);
                triggeredEndings.add(ending.id);

                // If the ending leads to another ending (e.g. dictator -> hitler_aftermath)
                const nextEnding = endingsData.find((e) => e.id === ending.leads_to);
                if (nextEnding) {
                  // Show the follow-up ending after a short delay
                  setTimeout(() => {
                    console.log(`üîó Triggering follow-up ending: ${nextEnding.id}`);
                    endGame(nextEnding.id, nextEnding.name, nextEnding.description);
                    triggeredEndings.add(nextEnding.id);
                  }, 2000);
                }
                return true;
              }

              // Normal ending
              console.log(`‚úÖ Triggering ending: ${ending.id}`);
              endGame(ending.id, ending.name, ending.description);
              triggeredEndings.add(ending.id);
              return true;
            }
          }
        }

        // Fallback: Basic failure conditions if no endings.json
        console.log("‚ö†Ô∏è Using fallback ending conditions");

        if (gameState.stats.conflict >= 85) {
          endGame("revolution", "üî• C√ÅCH M·∫†NG B√ôNG N·ªî", "Xung ƒë·ªôt ƒë·∫°t m·ª©c t·ªõi h·∫°n!");
          return true;
        }

        if (gameState.stats.economy <= 10) {
          endGame("economic_collapse", "ÔøΩ S·ª§P ƒê·ªî KINH T·∫æ", "N·ªÅn kinh t·∫ø s·ª•p ƒë·ªï ho√†n to√†n!");
          return true;
        }

        if (gameState.stats.environment <= 10) {
          endGame("environmental_disaster", "ÔøΩ TH·∫¢M H·ªåA M√îI TR∆Ø·ªúNG", "M√¥i tr∆∞·ªùng b·ªã t√†n ph√°!");
          return true;
        }

        // Natural end at max turns
        if (gameState.currentTurn > maxTurns) {
          endGame("natural_end", "‚è∞ K·∫æT TH√öC NHI·ªÜM K·ª≤", `Ho√†n th√†nh nhi·ªám k·ª≥ ${maxTurns} l∆∞·ª£t.`);
          return true;
        }

        console.log("‚ùå No ending conditions met");
        return false;
      }

      // End game
      function endGame(endingType, title, description) {
        console.log(`Game ended with: ${endingType}`);
        gameState.gameEnded = true;
        document.getElementById("endingTitle").textContent = title;
        document.getElementById("endingDescription").textContent = description;
        document.getElementById("gameEnd").style.display = "block";
        document.getElementById("choicesGrid").style.display = "none";
      }

      // Restart game
      function restartGame() {
        console.log("Restarting game...");

        // Reset game state
        gameState = {
          currentTurn: 1,
          stats: {
            discontent: 45,
            conflict: 35,
            economy: 55,
            environment: 50,
            freedom: 60,
            security: 45,
          },
          score: 0,
          gameEnded: false,
          eventHistory: [],
          usedScenarios: [],
        };

        dictatorModeTriggered = false;
        triggeredEndings.clear(); // Reset triggered endings

        // Reset event tracking
        usedEvents.clear();
        lastEventTurn = 0;

        // Remove difficulty indicator
        const indicator = document.getElementById("difficulty-indicator");
        if (indicator) indicator.remove();

        // Hide end screen
        document.getElementById("gameEnd").style.display = "none";
        document.getElementById("choicesGrid").style.display = "grid";
        document.getElementById("guideBtn").style.display = "none";

        // Hide game container and show start screen
        document.getElementById("gameContainer").style.display = "none";
        document.getElementById("startScreen").classList.remove("hidden");
      }

      // Update all displays
      function updateDisplay() {
        updateStatsDisplay();
        updateGameInfo();
      }

      // Guide functions
      function openGuide() {
        document.getElementById("guideModal").style.display = "flex";
      }

      function closeGuide() {
        document.getElementById("guideModal").style.display = "none";
      }

      // Close guide when clicking outside
      document.getElementById("guideModal").addEventListener("click", function (e) {
        if (e.target === this) {
          closeGuide();
        }
      });

      // Initialize when page loads
      window.addEventListener("load", function () {
        console.log("Political Simulator loaded with difficulty modes and comprehensive guide");
        // Add keyboard event listener
        window.addEventListener("keydown", handleKeyPress);
      });
    </script>
  </body>
</html>
