<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Người Cầm Quyền Simulator - With Difficulty Modes - v2.1</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-color: #6366f1;
        --secondary-color: #8b5cf6;
        --accent-color: #06d6a0;
        --danger-color: #ef4444;
        --warning-color: #f59e0b;
        --success-color: #10b981;
        --background-dark: #0f0f23;
        --background-secondary: #1a1a3a;
        --background-light: #2a2a4a;
        --text-primary: #f8fafc;
        --text-secondary: #cbd5e1;
        --text-muted: #94a3b8;
        --border-color: #334155;
        --shadow-color: rgba(99, 102, 241, 0.2);
        --glow-color: rgba(99, 102, 241, 0.4);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        width: 100%;
        overflow-x: hidden;
      }

      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        font-family: "Inter", sans-serif;
        background: radial-gradient(ellipse at top, var(--background-secondary) 0%, var(--background-dark) 70%);
        color: var(--text-primary);
        overflow-x: hidden;
        position: relative;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 20% 50%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 80%, rgba(6, 214, 160, 0.05) 0%, transparent 50%);
        pointer-events: none;
        z-index: -1;
      }

      /* Difficulty Selection Screen */
      .difficulty-selection {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(26, 26, 58, 0.95) 100%);
        backdrop-filter: blur(20px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .difficulty-modal {
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        padding: 40px;
        border-radius: 24px;
        max-width: 700px;
        width: 90%;
        text-align: center;
        border: 1px solid var(--border-color);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), 0 0 0 1px var(--shadow-color);
        position: relative;
        overflow: hidden;
        margin: 20px;
      }

      .difficulty-modal::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      }

      .difficulty-option {
        margin: 20px 0;
        padding: 30px;
        border: 2px solid var(--border-color);
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
        position: relative;
        overflow: hidden;
      }

      .difficulty-option::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.5s ease;
      }

      .difficulty-option:hover::before {
        left: 100%;
      }

      .difficulty-option:hover {
        border-color: var(--primary-color);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
        transform: translateY(-5px) scale(1.02);
        box-shadow: 0 20px 40px rgba(99, 102, 241, 0.2);
      }

      .difficulty-option h3 {
        margin: 0 0 15px 0;
        color: var(--text-primary);
        font-size: 1.5em;
        font-weight: 600;
        font-family: "Poppins", sans-serif;
        letter-spacing: -0.02em;
      }

      .difficulty-option p {
        margin: 0 0 15px 0;
        color: var(--text-secondary);
        font-size: 1.1em;
        line-height: 1.5;
      }

      .difficulty-stats {
        font-size: 0.95em;
        color: var(--text-muted);
        margin-top: 15px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      #difficulty-indicator {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 15px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 500;
        border: 1px solid #444;
      }

      /* Start Screen */
      .start-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--background-dark);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        text-align: center;
        transition: opacity 0.8s ease;
        overflow: hidden;
        padding: 20px;
        box-sizing: border-box;
      }

      .start-screen::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 30% 30%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 70% 70%, rgba(139, 92, 246, 0.15) 0%, transparent 50%);
        animation: pulse 4s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
      }

      .start-screen.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .start-title {
        font-family: "Poppins", sans-serif;
        font-size: 4em;
        font-weight: 800;
        color: var(--text-primary);
        text-align: center;
        margin-bottom: 20px;
        text-shadow: 0 0 20px var(--glow-color);
        letter-spacing: -0.02em;
        position: relative;
        z-index: 1;
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: titleGlow 3s ease-in-out infinite;
      }

      @keyframes titleGlow {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.2);
        }
      }

      .start-subtitle {
        font-size: 1.4em;
        color: var(--text-secondary);
        text-align: center;
        margin-bottom: 50px;
        font-weight: 300;
        position: relative;
        z-index: 1;
      }

      .start-btn {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
        border: none;
        padding: 18px 50px;
        font-size: 1.2em;
        font-weight: 600;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 10px 30px var(--shadow-color);
        position: relative;
        z-index: 1;
        font-family: "Poppins", sans-serif;
        overflow: hidden;
      }

      .start-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
      }

      .start-btn:hover::before {
        left: 100%;
      }

      .start-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 20px 50px var(--shadow-color);
      }

      /* Guide Button */
      .guide-btn {
        position: fixed;
        top: 30px;
        right: 30px;
        background: linear-gradient(135deg, var(--background-light), var(--background-secondary));
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 12px 24px;
        font-size: 0.9em;
        font-weight: 500;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 999;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: none;
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .guide-btn:hover {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        border-color: var(--primary-color);
        color: white;
        transform: translateY(-3px);
        box-shadow: 0 8px 25px var(--shadow-color);
      }

      /* Guide Modal */
      .guide-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 2000;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .guide-content {
        background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        padding: 30px;
        border-radius: 20px;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        border: 2px solid #444;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
      }

      .guide-title {
        font-size: 2rem;
        color: #fff;
        text-align: center;
        margin-bottom: 20px;
      }

      .guide-section {
        margin-bottom: 25px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      .guide-section h3 {
        color: #4caf50;
        font-size: 1.3em;
        margin-bottom: 15px;
      }

      .guide-section h4 {
        color: #ffd700;
        font-size: 1.1em;
        margin: 15px 0 10px 0;
      }

      .guide-section p,
      .guide-section li {
        color: #ccc;
        line-height: 1.6;
        margin-bottom: 8px;
      }

      .guide-section ul {
        margin-left: 20px;
      }

      .ending-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid;
      }

      .ending-success {
        border-left-color: #4caf50;
      }
      .ending-failure {
        border-left-color: #f44336;
      }
      .ending-special {
        border-left-color: #ff9800;
      }

      .close-guide {
        background: #f44336;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
        margin-top: 20px;
        float: right;
      }

      .close-guide:hover {
        background: #d32f2f;
      }

      /* Main Container */
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 30px;
        position: relative;
        width: 100%;
        box-sizing: border-box;
      }

      /* Game Layout - 2 Columns */
      .game-layout {
        display: grid;
        grid-template-columns: 350px 1fr;
        gap: 30px;
        align-items: start;
      }

      .left-panel {
        position: sticky;
        top: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
        padding: 20px;
        border-radius: 20px;
        border: 1px solid rgba(99, 102, 241, 0.2);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(99, 102, 241, 0.1);
      }

      .right-panel {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 30px;
        background: linear-gradient(135deg, rgba(6, 214, 160, 0.03) 0%, rgba(99, 102, 241, 0.03) 100%);
        padding: 20px;
        border-radius: 20px;
        border: 1px solid rgba(6, 214, 160, 0.1);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(6, 214, 160, 0.05);
      }

      /* Panel Titles */
      .panel-title {
        font-family: "Poppins", sans-serif;
        font-size: 1.1em;
        font-weight: 600;
        color: var(--primary-color);
        text-align: center;
        padding: 15px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
        border-radius: 12px;
        border: 1px solid rgba(99, 102, 241, 0.3);
        margin-bottom: 10px;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

      /* Alert Messages */
      .crisis-alert {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, var(--danger-color), #dc2626);
        color: white;
        padding: 15px 30px;
        border-radius: 50px;
        font-weight: 700;
        font-size: 1.1em;
        z-index: 2000;
        animation: alertSlide 0.5s ease-out, alertPulse 2s infinite 0.5s;
        box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4);
        display: none;
      }

      @keyframes alertSlide {
        from {
          top: -50px;
          opacity: 0;
        }
        to {
          top: 80px;
          opacity: 1;
        }
      }

      @keyframes alertPulse {
        0%,
        100% {
          transform: translateX(-50%) scale(1);
        }
        50% {
          transform: translateX(-50%) scale(1.05);
        }
      }

      /* Header */
      .header {
        text-align: center;
        margin-bottom: 40px;
        position: relative;
        width: 100%;
      }

      .header h1 {
        font-family: "Poppins", sans-serif;
        font-size: 3.2em;
        margin: 0 0 15px 0;
        font-weight: 700;
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px var(--glow-color);
        letter-spacing: -0.02em;
        line-height: 1.1;
      }

      .header .subtitle {
        font-size: 1.3em;
        color: var(--text-secondary);
        font-weight: 300;
        margin-bottom: 20px;
      }

      .header::after {
        content: "";
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        width: 100px;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      }

      /* Stats Panel */
      .stats-panel {
        display: grid;
        grid-template-columns: 1fr;
        gap: 15px;
        margin-bottom: 0;
        padding: 25px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
        border-radius: 20px;
        backdrop-filter: blur(20px);
        border: 1px solid var(--border-color);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        width: 100%;
        box-sizing: border-box;
      }

      .stat {
        text-align: center;
        padding: 25px 20px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
        border-radius: 16px;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
      }

      .stat::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .stat:hover::before {
        opacity: 1;
      }

      .stat:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 15px 40px rgba(99, 102, 241, 0.2);
        border-color: var(--primary-color);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      }

      .stat-label {
        font-size: 0.95em;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .stat-value {
        font-size: 2.5em;
        font-weight: 700;
        margin-bottom: 15px;
        font-family: "Poppins", sans-serif;
        transition: all 0.5s ease;
        position: relative;
      }

      .stat-value.changed {
        animation: statChange 1s ease-out;
      }

      .stat-value.increased {
        color: var(--success-color);
        text-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
      }

      .stat-value.decreased {
        color: var(--danger-color);
        text-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
      }

      @keyframes statChange {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Change Indicator */
      .stat-change {
        position: absolute;
        top: -10px;
        right: -10px;
        background: var(--success-color);
        color: white;
        border-radius: 50%;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8em;
        font-weight: 700;
        animation: changeIndicator 2s ease-out;
      }

      .stat-change.negative {
        background: var(--danger-color);
      }

      @keyframes changeIndicator {
        0% {
          opacity: 0;
          transform: scale(0) rotate(180deg);
        }
        20% {
          opacity: 1;
          transform: scale(1.2) rotate(0deg);
        }
        100% {
          opacity: 0;
          transform: scale(0.8) rotate(0deg);
        }
      }

      /* Effect Items in Choices */
      .effect-item {
        display: inline-block;
        padding: 2px 6px;
        margin: 0 2px;
        background: rgba(99, 102, 241, 0.1);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: 500;
      }

      .effect-item.high-impact-effect {
        background: rgba(239, 68, 68, 0.15);
        border-color: var(--danger-color);
        color: var(--danger-color);
        font-weight: 700;
        animation: highImpactEffect 2s infinite;
      }

      @keyframes highImpactEffect {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      /* Demo Animation */
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%) scale(0.8);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      /* Random Event Animations */
      @keyframes eventSlideIn {
        0% {
          opacity: 0;
          transform: translate(-50%, -60%) scale(0.7) rotate(5deg);
          filter: blur(10px);
        }
        50% {
          transform: translate(-50%, -45%) scale(1.05) rotate(0deg);
          filter: blur(2px);
        }
        100% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
          filter: blur(0px);
        }
      }

      @keyframes eventSlideOut {
        0% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -30%) scale(0.8);
          filter: blur(5px);
        }
      }

      @keyframes eventTitleGlow {
        0%,
        100% {
          text-shadow: 0 0 20px currentColor;
          transform: scale(1);
        }
        50% {
          text-shadow: 0 0 30px currentColor, 0 0 40px currentColor;
          transform: scale(1.02);
        }
      }

      .stat-bar {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
      }

      .stat-bar::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .stat-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--success-color), var(--accent-color));
        border-radius: 3px;
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      /* Stat Status Colors */
      .stat.critical {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(239, 68, 68, 0.1) 100%);
        border: 2px solid var(--danger-color);
        animation: criticalPulse 2s infinite;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
      }

      .stat.warning {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(245, 158, 11, 0.08) 100%);
        border: 2px solid var(--warning-color);
        animation: warningGlow 3s infinite;
      }

      .stat.good {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(16, 185, 129, 0.08) 100%);
        border: 2px solid var(--success-color);
      }

      @keyframes criticalPulse {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 30px rgba(239, 68, 68, 0.6);
        }
      }

      @keyframes warningGlow {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(245, 158, 11, 0.5);
        }
      }

      .stat-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        animation: fillShimmer 3s infinite;
      }

      @keyframes fillShimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      /* Game Info */
      .game-info {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 0;
        padding: 20px;
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        border-radius: 16px;
        border: 1px solid var(--border-color);
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        width: 100%;
        box-sizing: border-box;
      }

      .reload-btn {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
        border: 1px solid var(--primary-color);
        color: var(--text-primary);
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 500;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .reload-btn:hover {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        border-color: var(--primary-color);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px var(--shadow-color);
      }

      .demo-btn {
        background: linear-gradient(135deg, var(--warning-color), #d97706);
        border: 1px solid var(--warning-color);
        color: white;
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        animation: demoGlow 3s infinite;
      }

      .demo-btn:hover {
        background: linear-gradient(135deg, #d97706, #b45309);
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
      }

      @keyframes demoGlow {
        0%,
        100% {
          box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        50% {
          box-shadow: 0 6px 25px rgba(245, 158, 11, 0.5);
        }
      }

      .change-difficulty-btn {
        background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
        border: 1px solid var(--secondary-color);
        color: white;
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        animation: changeModeGlow 3s infinite;
      }

      .change-difficulty-btn:hover {
        background: linear-gradient(135deg, var(--accent-color), var(--secondary-color));
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
      }

      @keyframes changeModeGlow {
        0%,
        100% {
          box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }
        50% {
          box-shadow: 0 6px 25px rgba(139, 92, 246, 0.5);
        }
      }

      .debug-btn {
        background: linear-gradient(135deg, var(--accent-color), var(--success-color));
        border: 1px solid var(--accent-color);
        color: white;
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .debug-btn:hover {
        background: linear-gradient(135deg, var(--success-color), var(--accent-color));
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 8px 25px rgba(6, 214, 160, 0.4);
      }

      .turn-counter,
      .scenario-counter {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--warning-color);
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        padding: 8px 16px;
        background: rgba(245, 158, 11, 0.1);
        border-radius: 20px;
        border: 1px solid rgba(245, 158, 11, 0.3);
        transition: all 0.3s ease;
      }

      /* Late Game Warning */
      .turn-counter.late-game {
        color: var(--danger-color);
        background: rgba(239, 68, 68, 0.15);
        border-color: var(--danger-color);
        animation: lateGamePulse 2s infinite;
      }

      @keyframes lateGamePulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .scenario-counter {
        color: var(--success-color);
        background: rgba(16, 185, 129, 0.1);
        border-color: rgba(16, 185, 129, 0.3);
      }

      .game-score {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--accent-color);
        padding: 8px 16px;
        background: rgba(6, 214, 160, 0.1);
        border-radius: 20px;
        border: 1px solid rgba(6, 214, 160, 0.3);
      }

      /* Story Section */
      .story-section {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.04) 100%);
        padding: 35px;
        border-radius: 20px;
        margin-bottom: 0;
        border: 1px solid var(--border-color);
        position: relative;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }

      .story-section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        border-radius: 20px 20px 0 0;
      }

      .story-section.loading {
        opacity: 0.7;
        transform: scale(0.98);
        filter: blur(0.5px);
      }

      .story-title {
        font-size: 1.8em;
        font-weight: 600;
        margin-bottom: 20px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
        letter-spacing: -0.01em;
      }

      .story-text {
        font-size: 1.15em;
        line-height: 1.7;
        margin-bottom: 25px;
        color: var(--text-secondary);
      }

      /* Choices */
      .choices-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
        margin-bottom: 0;
        width: 100%;
      }

      .choice {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%);
        padding: 30px;
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        border: 2px solid var(--border-color);
        transform: translateY(0);
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }

      .choice::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.6s ease;
      }

      .choice:hover:not(.disabled)::before {
        left: 100%;
      }

      .choice.disabled {
        pointer-events: none;
        opacity: 0.4;
        transform: scale(0.95);
        filter: grayscale(70%);
        background: rgba(100, 100, 100, 0.05);
      }

      .choice:hover:not(.disabled) {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
        border-color: var(--primary-color);
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 15px 40px rgba(99, 102, 241, 0.2);
      }

      /* High Impact Choices */
      .choice.high-impact {
        border: 2px solid var(--danger-color);
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);
        animation: highImpactGlow 3s infinite;
      }

      .choice.high-impact .choice-title {
        color: var(--danger-color);
        font-weight: 700;
      }

      .choice.high-impact .choice-effects {
        background: rgba(239, 68, 68, 0.15);
        border: 1px solid var(--danger-color);
        color: var(--text-primary);
        font-weight: 600;
      }

      @keyframes highImpactGlow {
        0%,
        100% {
          box-shadow: 0 4px 20px rgba(239, 68, 68, 0.2);
        }
        50% {
          box-shadow: 0 8px 30px rgba(239, 68, 68, 0.4);
        }
      }

      .choice-title {
        font-size: 1.3em;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
      }

      .choice-text {
        line-height: 1.6;
        margin-bottom: 20px;
        color: var(--text-secondary);
      }

      .choice-effects {
        font-size: 0.95em;
        color: var(--text-muted);
        background: rgba(0, 0, 0, 0.2);
        padding: 12px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-weight: 500;
      }

      /* Random Event */
      .random-event {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        color: var(--text-primary);
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        animation: eventSlideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6), 0 0 0 1px var(--border-color);
        border: 2px solid var(--primary-color);
        max-width: 700px;
        width: 90%;
        z-index: 1500;
        display: none;
        backdrop-filter: blur(20px);
        position: relative;
        overflow: hidden;
      }

      @keyframes eventSlideIn {
        from {
          transform: translate(-50%, -60%) scale(0.8);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      .random-event::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        animation: eventGlow 2s ease-in-out infinite;
      }

      @keyframes eventGlow {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
      }

      .event-title {
        font-size: 1.8em;
        font-weight: 700;
        margin-bottom: 20px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
        letter-spacing: -0.01em;
        position: relative;
        z-index: 1;
      }

      .event-description {
        font-size: 1.2em;
        line-height: 1.6;
        margin-bottom: 25px;
        color: var(--text-secondary);
        position: relative;
        z-index: 1;
      }

      .event-effects {
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.2) 100%);
        padding: 25px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        backdrop-filter: blur(10px);
        position: relative;
        z-index: 1;
      }

      .effects-title {
        font-size: 1.1em;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .effects-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
        font-size: 0.95em;
      }

      .effect-item {
        padding: 12px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
        border-radius: 8px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
      }

      .effect-item:hover {
        transform: scale(1.05);
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.1) 100%);
      }

      .effect-positive {
        color: var(--success-color);
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
      }

      .effect-negative {
        color: var(--danger-color);
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      }

      .effect-neutral {
        color: var(--warning-color);
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
      }

      /* Game End */
      .game-end {
        text-align: center;
        padding: 50px;
        background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
        border-radius: 24px;
        margin-top: 40px;
        border: 1px solid var(--border-color);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(20px);
        position: relative;
        overflow: hidden;
      }

      .game-end::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        animation: endingGlow 3s ease-in-out infinite;
      }

      @keyframes endingGlow {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      .game-end h2 {
        font-size: 3em;
        margin-bottom: 25px;
        color: var(--primary-color);
        font-family: "Poppins", sans-serif;
        font-weight: 700;
        letter-spacing: -0.02em;
        position: relative;
        z-index: 1;
      }

      .ending-description {
        font-size: 1.4em;
        line-height: 1.7;
        margin-bottom: 40px;
        color: var(--text-secondary);
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        z-index: 1;
      }

      .restart-btn {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
        border: none;
        padding: 18px 40px;
        font-size: 1.2em;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        font-family: "Poppins", sans-serif;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        position: relative;
        z-index: 1;
        overflow: hidden;
      }

      .restart-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
      }

      .restart-btn:hover::before {
        left: 100%;
      }

      .restart-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px var(--shadow-color);
      }

      /* Responsive Design */
      @media (max-width: 1200px) {
        .container {
          padding: 20px;
        }

        .header h1 {
          font-size: 3em;
        }

        .game-layout {
          grid-template-columns: 320px 1fr;
          gap: 25px;
        }

        .stats-panel {
          padding: 20px;
        }
      }

      @media (max-width: 992px) {
        .game-layout {
          grid-template-columns: 1fr;
          gap: 30px;
        }

        .left-panel {
          position: static;
          order: 1;
        }

        .right-panel {
          order: 2;
          min-height: auto;
        }

        .stats-panel {
          grid-template-columns: repeat(3, 1fr);
          gap: 15px;
        }

        .game-info {
          flex-direction: row;
          flex-wrap: wrap;
          justify-content: space-between;
        }
      }

      @media (max-width: 768px) {
        .container {
          padding: 15px;
          max-width: 100%;
        }

        .start-title {
          font-size: 2.5em;
        }

        .header h1 {
          font-size: 2.3em;
        }

        .game-layout {
          grid-template-columns: 1fr;
          gap: 20px;
        }

        .stats-panel {
          grid-template-columns: repeat(2, 1fr);
          gap: 12px;
          padding: 18px;
        }

        .stat {
          padding: 15px 10px;
        }

        .stat-value {
          font-size: 1.8em;
        }

        .choice {
          padding: 20px;
        }

        .game-info {
          flex-direction: column;
          gap: 10px;
          padding: 15px;
          text-align: center;
        }

        .turn-counter,
        .scenario-counter,
        .game-score {
          font-size: 1em;
          padding: 8px 12px;
        }

        .difficulty-modal,
        .guide-content {
          margin: 10px;
          padding: 25px;
          width: calc(100% - 20px);
        }

        .story-section {
          padding: 20px;
        }

        .random-event {
          padding: 25px;
          width: calc(100% - 20px);
          margin: 10px;
        }

        .game-end {
          padding: 30px;
        }

        .game-end h2 {
          font-size: 2.2em;
        }
      }

      @media (max-width: 480px) {
        .container {
          padding: 10px;
        }

        .start-title {
          font-size: 2em;
        }

        .header h1 {
          font-size: 1.8em;
        }

        .game-layout {
          gap: 15px;
        }

        .stats-panel {
          grid-template-columns: 1fr;
          gap: 8px;
          padding: 15px;
        }

        .stat {
          padding: 12px 8px;
        }

        .stat-value {
          font-size: 1.6em;
        }

        .choice {
          padding: 18px;
        }

        .story-section {
          padding: 18px;
        }

        .game-info {
          padding: 12px;
          gap: 8px;
        }

        .random-event {
          padding: 20px;
          width: calc(100% - 20px);
        }

        .game-end {
          padding: 20px;
        }

        .game-end h2 {
          font-size: 1.8em;
        }

        .difficulty-modal,
        .guide-content {
          margin: 5px;
          padding: 20px;
          width: calc(100% - 10px);
        }

        .turn-counter,
        .scenario-counter,
        .game-score {
          font-size: 0.9em;
          padding: 6px 10px;
        }
      }

      /* Dark mode optimizations */
      @media (prefers-color-scheme: dark) {
        :root {
          --background-dark: #0a0a0f;
          --background-secondary: #151525;
          --background-light: #202040;
        }
      }

      /* High contrast mode */
      @media (prefers-contrast: high) {
        :root {
          --border-color: #666;
          --text-secondary: #fff;
        }

        .choice,
        .stat,
        .story-section {
          border-width: 2px;
        }
      }

      /* Reduced motion */
      @media (prefers-reduced-motion: reduce) {
        * {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }
    </style>
  </head>
  <body>
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
      <h1 class="start-title">NGƯỜI CẦM QUYỀN</h1>
      <p class="start-subtitle">🎮 Simulator Chính Trị Chiến Lược 🎮</p>
      <button class="start-btn" onclick="showDifficultySelection()">
        <span>🚀 BẮT ĐẦU GAME</span>
      </button>
    </div>

    <!-- Guide Button -->
    <button class="guide-btn" onclick="openGuide()" id="guideBtn">HƯỚNG DẪN</button>

    <!-- Guide Modal -->
    <div class="guide-modal" id="guideModal">
      <div class="guide-content">
        <h2 class="guide-title">HƯỚNG DẪN GAME</h2>

        <div class="guide-section">
          <h3>Cách Chơi Cơ Bản</h3>
          <p><strong>Mục tiêu:</strong> Duy trì quyền lực và dẫn dắt đất nước thông qua các quyết định chính trị.</p>
          <p><strong>Cơ chế:</strong> Mỗi lượt, bạn sẽ đối mặt với các tình huống và phải chọn 1 trong 2-3 lựa chọn.</p>
          <p>
            <strong>Chỉ số quan trọng:</strong> Quản lý 6 chỉ số - Bất Mãn, Xung Đột, Kinh Tế, Môi Trường, Tự Do, An
            Ninh.
          </p>
        </div>

        <div class="guide-section">
          <h3>Độ Khó</h3>
          <p>
            <strong>Easy Mode (15 rounds):</strong> Tác động tiêu cực giảm 30%, tác động tích cực tăng 20%, ít sự kiện
            ngẫu nhiên
          </p>
          <p>
            <strong>Normal Mode (30 rounds):</strong> Cân bằng hoàn hảo, tác động chuẩn, vừa phải sự kiện ngẫu nhiên
          </p>
          <p>
            <strong>Hard Mode (50 rounds):</strong> Tác động tiêu cực tăng 40%, tác động tích cực giảm 20%, nhiều sự
            kiện ngẫu nhiên
          </p>
        </div>

        <div class="guide-section">
          <h3>Các Kết Thúc Có Thể Gặp</h3>

          <div class="ending-item ending-success">
            <h4>NHÀ LÃNH ĐẠO TÀI BA - BEST LEADER EVER</h4>
            <p>
              <strong>Điều kiện:</strong> Bất Mãn ≤20, Xung Đột ≤25, Kinh Tế ≥70, Môi Trường ≥60, Tự Do ≥65, An Ninh ≥60
            </p>
            <p>Kết thúc hoàn hảo nhất! Bạn cân bằng xuất sắc tất cả các yếu tố xã hội.</p>
          </div>

          <div class="ending-item ending-special">
            <h4>ĐỘC TÀI QUÂN SỰ (TẠM THỜI)</h4>
            <p><strong>Điều kiện:</strong> An Ninh ≥75, Tự Do ≤25</p>
            <p>Dẫn đến ending Hitler Collapse sau 2 giây. Quyền lực tuyệt đối không bền vững.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>HẬU QUẢ CỦA ĐỘC TÀI - DICTATOR'S COLLAPSE</h4>
            <p><strong>Điều kiện:</strong> Sau khi trở thành độc tài</p>
            <p>"You look like Hitler after this you will collapse!" - Cách mạng lật đổ chế độ độc tài.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>CÁCH MẠNG BÙNG NỔ</h4>
            <p><strong>Điều kiện:</strong> Xung Đột ≥85</p>
            <p>Người dân nổi dậy và lật đổ chính quyền khi xung đột xã hội quá cao.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>MẤT QUYỀN LỰC</h4>
            <p><strong>Điều kiện:</strong> Bất Mãn ≥80</p>
            <p>Dân chúng bất mãn tới mức truất phế bạn khỏi chức vụ.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>SỤP ĐỔ KINH TẾ</h4>
            <p><strong>Điều kiện:</strong> Kinh Tế ≤10</p>
            <p>Nền kinh tế sụp đổ hoàn toàn, đất nước rơi vào khủng hoảng.</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>THẢM HỌA MÔI TRƯỜNG</h4>
            <p><strong>Điều kiện:</strong> Môi Trường ≤10</p>
            <p>Biến đổi khí hậu và ô nhiễm làm đất nước không thể sinh sống.</p>
          </div>

          <div class="ending-item ending-success">
            <h4>HOÀNG ĐẾ KINH TẾ</h4>
            <p><strong>Điều kiện:</strong> Kinh Tế ≥85 (sau turn 10)</p>
            <p>Phát triển nền kinh tế mạnh mẽ, biến đất nước thành cường quốc.</p>
          </div>

          <div class="ending-item ending-success">
            <h4>VUA BẢO VỆ MÔI TRƯỜNG</h4>
            <p><strong>Điều kiện:</strong> Môi Trường ≥85 (sau turn 10)</p>
            <p>Biến đất nước thành thiên đường xanh với môi trường hoàn hảo.</p>
          </div>

          <div class="ending-item ending-special">
            <h4>KẾT THÚC NHIỆM KỲ</h4>
            <p><strong>Điều kiện:</strong> Hoàn thành hết số rounds</p>
            <p>Kết thúc tự nhiên, đánh giá dựa trên các chỉ số cuối game.</p>
          </div>
        </div>

        <div class="guide-section">
          <h3>Điều Kiện Logic & Sự Kiện Có Điều Kiện</h3>

          <h4>Hệ Thống Sự Kiện Thông Minh</h4>
          <p>
            Game sử dụng hệ thống sự kiện có điều kiện logic, nghĩa là các sự kiện chỉ xuất hiện khi các chỉ số đạt
            ngưỡng nhất định:
          </p>

          <div class="ending-item ending-failure">
            <h4>Sự Kiện An Ninh Thấp</h4>
            <p><strong>Điều kiện:</strong> An Ninh ≤ 30</p>
            <p><strong>Kích hoạt:</strong> Tấn công mạng, cướp ngân hàng, khủng bố</p>
            <p>Khi an ninh yếu kém, tội phạm gia tăng và các mối đe dọa xuất hiện</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>Sự Kiện Kinh Tế Khủng Hoảng</h4>
            <p><strong>Điều kiện:</strong> Kinh Tế ≤ 25</p>
            <p><strong>Kích hoạt:</strong> Sập tiệm vàng, khủng hoảng thực phẩm, thất nghiệp cao</p>
            <p>Suy thoái kinh tế dẫn đến các vấn đề xã hội nghiêm trọng</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>Sự Kiện Môi Trường Xấu</h4>
            <p><strong>Điều kiện:</strong> Môi Trường ≤ 25</p>
            <p><strong>Kích hoạt:</strong> Ô nhiễm sông, siêu bão cực đoan, thảm họa sinh thái</p>
            <p>Môi trường tồi tệ gây ra các thiên tai và ô nhiễm nghiêm trọng</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>Sự Kiện Độc Tài</h4>
            <p><strong>Điều kiện:</strong> Tự Do ≤ 25 + An Ninh ≥ 60</p>
            <p><strong>Kích hoạt:</strong> Biểu tình đòi dân chủ, kiểm duyệt báo chí</p>
            <p>Chế độ độc tài gây phản ứng mạnh mẽ từ dân chúng đòi tự do</p>
          </div>

          <div class="ending-item ending-failure">
            <h4>Sự Kiện Bạo Loạn</h4>
            <p><strong>Điều kiện:</strong> Xung Đột ≥ 60 + Bất Mãn ≥ 50</p>
            <p><strong>Kích hoạt:</strong> Bạo loạn thành phố, đấu tranh vũ trang</p>
            <p>Căng thẳng xã hội cao dẫn đến bạo động và mất trật tự</p>
          </div>

          <div class="ending-item ending-success">
            <h4>Sự Kiện Tích Cực</h4>
            <p><strong>Điều kiện:</strong> Kinh Tế ≥ 70 + Tự Do ≥ 60 + An Ninh ≥ 60</p>
            <p><strong>Kích hoạt:</strong> Đầu tư nước ngoài, công nhận quốc tế</p>
            <p>Môi trường ổn định thu hút đầu tư và phát triển bền vững</p>
          </div>

          <h4>Cách Thức Hoạt Động</h4>
          <ul>
            <li><strong>Kiểm tra điều kiện:</strong> Mỗi turn, hệ thống kiểm tra tất cả điều kiện</li>
            <li><strong>Xác suất kích hoạt:</strong> Các sự kiện có điều kiện có xác suất riêng (60-90%)</li>
            <li><strong>Tác động kép:</strong> Sự kiện vừa phản ánh tình hình, vừa làm tình hình xấu hơn</li>
            <li><strong>Chuỗi phản ứng:</strong> Một sự kiện có thể tạo điều kiện cho sự kiện khác</li>
          </ul>
        </div>

        <div class="guide-section">
          <h3>Chiến Thuật & Tips</h3>

          <h4>Chiến Lược Cơ Bản</h4>
          <ul>
            <li><strong>Cân bằng là chìa khóa:</strong> Đừng để bất kỳ chỉ số nào quá thấp hoặc quá cao</li>
            <li><strong>Ưu tiên Kinh Tế:</strong> Nền kinh tế mạnh giúp giải quyết nhiều vấn đề</li>
            <li><strong>Kiểm soát Xung Đột:</strong> Luôn giữ dưới 80, sử dụng đối thoại khi cần</li>
            <li><strong>Đầu tư dài hạn:</strong> Môi Trường và Giáo Dục tạo nền tảng bền vững</li>
            <li><strong>Linh hoạt:</strong> Thích ứng với sự kiện ngẫu nhiên và điều chỉnh chiến lược</li>
          </ul>

          <h4>Phòng Ngừa Khủng Hoảng</h4>
          <ul>
            <li><strong>Giám sát chỉ số:</strong> Theo dõi các chỉ số nguy hiểm (An Ninh, Kinh Tế, Tự Do)</li>
            <li><strong>Can thiệp kịp thời:</strong> Không để chỉ số nào xuống quá thấp</li>
            <li><strong>Cân bằng lực lượng:</strong> Tránh tình trạng một chỉ số quá cao, một chỉ số quá thấp</li>
            <li><strong>Chuẩn bị ứng phó:</strong> Dự trữ nguồn lực để xử lý khủng hoảng</li>
          </ul>
        </div>

        <button class="close-guide" onclick="closeGuide()">ĐÓNG</button>
      </div>
    </div>

    <!-- Main Game -->
    <div class="container" id="gameContainer" style="display: none">
      <!-- Header -->
      <div class="header">
        <h1>🏛️ NGƯỜI CẦM QUYỀN 🏛️</h1>
        <div class="subtitle">⚖️ Quyết định tương lai đất nước ⚖️</div>
      </div>

      <!-- Game Layout - 2 Columns -->
      <div class="game-layout">
        <!-- Left Column - Stats & Info -->
        <div class="left-panel">
          <div class="panel-title">📊 BẢNG ĐIỀU KHIỂN</div>

          <!-- Stats Panel -->
          <div class="stats-panel" id="statsPanel">
            <!-- Stats will be populated by JavaScript -->
          </div>

          <!-- Game Info -->
          <div class="game-info">
            <div class="turn-counter">Lượt <span id="turnCounter">1</span></div>
            <div class="scenario-counter">Tình huống: <span id="scenarioCount">2</span>/20</div>
            <div class="game-score">Điểm <span id="gameScore">0</span></div>
            <button
              id="reloadDataBtn"
              class="reload-btn"
              onclick="reloadGameData()"
              title="Tải lại dữ liệu game sau khi setup server"
            >
              🔄 Tải lại dữ liệu
            </button>
            <button onclick="demoRandomEvent()" class="demo-btn" title="Xem demo random event">🎲 Demo Event</button>
            <button onclick="changeDifficulty()" class="change-difficulty-btn" title="Đổi độ khó và reset game">
              ⚙️ Đổi Mode
            </button>
          </div>
        </div>

        <!-- Right Column - Story & Choices -->
        <div class="right-panel">
          <div class="panel-title">📖 TÌNH HUỐNG & LỰA CHỌN</div>

          <!-- Story Section -->
          <div class="story-section">
            <div class="story-title" id="storyTitle">Bắt đầu nhiệm kỳ</div>
            <div class="story-text" id="storyText">
              Chào mừng đến với ghế quyền lực. Những quyết định của bạn sẽ định hình tương lai của đất nước.
            </div>
          </div>

          <!-- Choices -->
          <div class="choices-grid" id="choicesGrid">
            <!-- Choices will be populated by JavaScript -->
          </div>

          <div class="game-end" id="gameEnd" style="display: none">
            <h2 id="endingTitle">Game Over</h2>
            <div class="ending-description" id="endingDescription"></div>
            <button class="restart-btn" onclick="restartGame()">Chơi lại</button>
          </div>
        </div>
      </div>

      <!-- Random Events now display as center screen popups -->

      <!-- Game End -->
      <!-- <div class="game-end" id="gameEnd" style="display: none">
        <h2 id="endingTitle">Game Over</h2>
        <div class="ending-description" id="endingDescription"></div>
        <button class="restart-btn" onclick="restartGame()">Chơi lại</button>
      </div> -->
    </div>

    <script>
      // === DIFFICULTY MODES SYSTEM ===

      // Gemini AI Configuration
      const GEMINI_API_KEY = "AIzaSyC9gp_B0IZiOW1LBGtaFjGD9wnVmcuYxD0";
      // const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      // const apiKey = "YOUR_API_KEY";
      const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";
      let aiGeneratedStoryCache = [];

      // Global game state
      let currentDifficulty = "normal";
      let maxTurns = 30;
      let gameState = {
        turnMode: 1,
        currentTurn: 1,
        stats: {
          discontent: 45,
          conflict: 35,
          economy: 55,
          environment: 50,
          freedom: 60,
          security: 45,
        },
        score: 0,
        gameEnded: false,
        eventHistory: [],
        usedScenarios: [],
      };

      // Difficulty modes configuration - UPDATED ROUNDS
      const DIFFICULTY_MODES = {
        easy: {
          name: "DỄ - Easy Mode",
          description: "Bắt đầu với buffer tốt cho random events - Perfect for beginners",
          startingStats: {
            discontent: 30,
            conflict: 20,
            economy: 75,
            environment: 70,
            freedom: 75,
            security: 65,
          },
          effectMultiplier: 0.6, // Giảm tác động tiêu cực
          positiveBoost: 1.3, // Tăng tác động tích cực
          randomEventsFrequency: 0.2, // Điều chỉnh cho phù hợp
          maxTurns: 15, // UPDATED: 15 rounds
        },
        normal: {
          name: "BÌNH THƯỜNG - Normal Mode",
          description: "Cân bằng với random events - Can breathe :D",
          startingStats: {
            discontent: 40,
            conflict: 30,
            economy: 60,
            environment: 55,
            freedom: 65,
            security: 50,
          },
          effectMultiplier: 1.0,
          positiveBoost: 1.0,
          randomEventsFrequency: 0.3, // Cân bằng với buffer stats
          maxTurns: 30, // UPDATED: 30 rounds
        },
        hard: {
          name: "KHÓ - Hard Mode",
          description: "Thử thách với nhiều random events - Most hard to play",
          startingStats: {
            discontent: 50,
            conflict: 40,
            economy: 50,
            environment: 45,
            freedom: 55,
            security: 40,
          },
          effectMultiplier: 1.3, // Giảm xuống để cân bằng
          positiveBoost: 0.9, // Cải thiện để không quá khó
          randomEventsFrequency: 0.4, // Vẫn cao nhưng không quá mức
          maxTurns: 50, // UPDATED: 50 rounds
        },
      };

      // Stat labels
      const statLabels = {
        discontent: "🔥 Bất Mãn",
        conflict: "⚔️ Xung Đột",
        economy: "💰 Kinh Tế",
        environment: "🌍 Môi Trường",
        freedom: "🗽 Tự Do",
        security: "🛡️ An Ninh",
      };

      // Game data
      let gameStoryData = [];
      let randomEventsWithChoicesData = [];

      // Event tracking to prevent repetition
      let usedEvents = new Set();
      let lastEventTurn = 0;
      let eventCooldown = 2; // Giảm cooldown để events xuất hiện thường xuyên hơn
      let minEventTurn = 3; // Events không trigger trước lượt 3
      let endingsData = [];
      let dictatorModeTriggered = false;
      let triggeredEndings = new Set(); // Track endings đã được trigger

      // Demo function to trigger random event immediately
      function demoRandomEvent() {
        console.log("🎪 Demo: Triggering random event...");

        if (randomEventsWithChoicesData.length > 0) {
          // Pick a random event for demo
          const randomEvent =
            randomEventsWithChoicesData[Math.floor(Math.random() * randomEventsWithChoicesData.length)];

          // Create demo event display
          const demoDiv = document.createElement("div");
          demoDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            padding: 30px;
            border-radius: 20px;
            border: 2px solid #f59e0b;
            max-width: 650px;
            z-index: 10000;
            box-shadow: 0 25px 60px rgba(0,0,0,0.7);
            animation: slideIn 0.5s ease-out;
            backdrop-filter: blur(10px);
          `;

          // Determine event severity color
          const isHighImpact = Object.values(randomEvent.effects).some((val) => Math.abs(val) >= 15);
          const severityColor = isHighImpact ? "#ef4444" : "#f59e0b";
          const severityIcon = isHighImpact ? "💥" : "⚡";

          demoDiv.innerHTML = `
            <div style="text-align: center; margin-bottom: 25px;">
              <h2 style="color: ${severityColor}; margin-bottom: 10px; font-size: 1.5em;">
                ${severityIcon} RANDOM EVENT DEMO ${severityIcon}
              </h2>
              <div style="background: rgba(245, 158, 11, 0.1); padding: 8px 16px; border-radius: 20px; display: inline-block; font-size: 0.9em; color: #f59e0b;">
                ID: ${randomEvent.id} | ${randomEvent.rarity?.toUpperCase() || "NORMAL"}
              </div>
            </div>
            
            <h3 style="color: #f59e0b; margin-bottom: 15px; text-align: center; font-size: 1.4em;">
              ${randomEvent.title}
            </h3>
            
            <p style="margin-bottom: 25px; line-height: 1.6; text-align: center; font-size: 1.1em; color: #e2e8f0;">
              ${randomEvent.text}
            </p>
            
            <div style="background: rgba(99, 102, 241, 0.1); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 1px solid rgba(99, 102, 241, 0.3);">
              <h4 style="color: #6366f1; margin-bottom: 15px; text-align: center;">📊 Tác Động Lên Chỉ Số:</h4>
              <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                ${Object.entries(randomEvent.effects)
                  .map(
                    ([stat, change]) =>
                      `<span style="
                    display: inline-block; 
                    padding: 8px 12px; 
                    background: ${change > 0 ? "rgba(239, 68, 68, 0.2)" : "rgba(16, 185, 129, 0.2)"}; 
                    border: 1px solid ${change > 0 ? "#ef4444" : "#10b981"};
                    border-radius: 20px; 
                    color: ${change > 0 ? "#ef4444" : "#10b981"};
                    font-weight: 600;
                    font-size: 0.95em;
                    ${Math.abs(change) >= 15 ? "animation: highImpactEffect 2s infinite;" : ""}
                  ">
                    ${statLabels[stat] || stat}: ${change > 0 ? "+" : ""}${change}
                  </span>`
                  )
                  .join("")}
              </div>
            </div>
            
            ${
              randomEvent.conditions
                ? `
              <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px; border: 1px solid rgba(139, 92, 246, 0.3);">
                <h5 style="color: #8b5cf6; margin-bottom: 10px; text-align: center;">🎯 Điều Kiện Kích Hoạt:</h5>
                <div style="font-size: 0.9em; color: #cbd5e1; text-align: center;">
                  ${Object.entries(randomEvent.conditions)
                    .filter(([key]) => key !== "min_turn")
                    .map(([stat, condition]) => {
                      if (typeof condition === "object") {
                        return `${statLabels[stat] || stat}: ${condition.min ? "≥" + condition.min : ""}${
                          condition.max ? "≤" + condition.max : ""
                        }`;
                      }
                      return `${stat}: ${condition}`;
                    })
                    .join(" • ")}
                  ${randomEvent.conditions.min_turn ? `• Từ lượt ${randomEvent.conditions.min_turn}` : ""}
                </div>
              </div>
            `
                : ""
            }
            
            <div style="text-align: center;">
              <button onclick="this.parentElement.parentElement.remove()" 
                      style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; padding: 15px 30px; border-radius: 25px; cursor: pointer; font-weight: 600; font-size: 1.1em; transition: all 0.3s ease;">
                🎮 Đóng Demo
              </button>
            </div>
          `;

          document.body.appendChild(demoDiv);

          // Add hover effect to close button
          const closeBtn = demoDiv.querySelector("button");
          closeBtn.addEventListener("mouseenter", function () {
            this.style.transform = "scale(1.05)";
            this.style.boxShadow = "0 8px 25px rgba(245, 158, 11, 0.4)";
          });
          closeBtn.addEventListener("mouseleave", function () {
            this.style.transform = "scale(1)";
            this.style.boxShadow = "none";
          });
        } else {
          // Fallback demo with sample data if events not loaded
          const sampleEvent = {
            id: "DEMO",
            title: "DEMO: TẤN CÔNG MẠNG QUY MÔ LỚN!",
            text: "Đây là demo một random event. Nhóm hacker quốc tế tấn công hệ thống ngân hàng do hệ thống bảo mật yếu kém!",
            effects: {
              discontent: 15,
              conflict: 10,
              economy: -12,
              freedom: -8,
              security: -10,
            },
            rarity: "conditional",
            conditions: {
              security: { max: 30 },
              min_turn: 3,
            },
          };

          // Use sample event for demo
          alert("Đang load demo event... Random events data chưa sẵn sàng!");
          console.log("Sample demo event:", sampleEvent);
        }
      }

      // Function to change difficulty (auto-reset stats)
      function changeDifficulty() {
        if (confirm("⚙️ Bạn có muốn đổi độ khó không? Game sẽ được reset và áp dụng chỉ số mới.")) {
          console.log("⚙️ Changing difficulty...");

          // Hide current game
          document.getElementById("gameContainer").style.display = "none";

          // Show difficulty selection again với chế độ reset
          showDifficultySelection(true); // true = reset mode

          console.log("✅ Difficulty selection shown");
        }
      }

      // Function riêng để RESET và chọn mode mới
      function selectDifficultyAndReset(difficulty) {
        currentDifficulty = difficulty;
        const mode = DIFFICULTY_MODES[difficulty];

        console.log(`🔄 RESETTING game and selecting difficulty: ${difficulty}`, mode);

        // RESET HOÀN TOÀN game state
        gameState = {
          turnMode: mode.maxTurns,
          currentTurn: 1,
          usedScenarios: [],
          stats: { ...mode.startingStats },
          score: 0,
        };

        maxTurns = mode.maxTurns;

        // Reset events tracking
        usedEvents.clear();
        lastEventTurn = 0;

        // Remove difficulty selection screen
        const difficultyModal = document.getElementById("difficultySelection");
        if (difficultyModal) {
          difficultyModal.remove();
        }

        // Remove existing difficulty indicator if any
        const existingIndicator = document.getElementById("difficulty-indicator");
        if (existingIndicator) {
          existingIndicator.remove();
        }

        // Show new difficulty indicator
        showDifficultyIndicator(mode.name);

        console.log(`✅ Game RESET with new stats:`, gameState.stats);

        // ✨ CẬP NHẬT UI VỚI STATS MỚI
        updateDisplay();

        // Start game
        startGame();
      }

      // Function to show difficulty selection screen
      function showDifficultySelection(resetMode = false) {
        document.getElementById("startScreen").classList.add("hidden");

        const functionToCall = resetMode ? "selectDifficultyAndReset" : "selectDifficulty";
        const titleText = resetMode ? "🔄 ĐỔI ĐỘ KHÓ & RESET" : "🎮 CHỌN ĐỘ KHÓ";

        const difficultyHTML = `
        <div class="difficulty-selection" id="difficultySelection">
          <div class="difficulty-modal">
            <h2 style="color: #fff; margin-bottom: 20px; font-size: 2rem;">${titleText}</h2>
            <p style="color: #ccc; margin-bottom: 30px;">SELECT DIFFICULTY MODE</p>
            
            <div class="difficulty-options">
              ${Object.entries(DIFFICULTY_MODES)
                .map(
                  ([key, mode]) => `
                <div class="difficulty-option" onclick="${functionToCall}('${key}')">
                  <h3>${mode.name}</h3>
                  <p>${mode.description}</p>
                  <div class="difficulty-stats">
                    Economy ${mode.startingStats.economy} | Security ${mode.startingStats.security} | Freedom ${
                    mode.startingStats.freedom
                  } | 
                    Rounds: ${mode.maxTurns} | 
                    Events: ${Math.round(mode.randomEventsFrequency * 100)}%
                  </div>
                </div>
              `
                )
                .join("")}
            </div>
          </div>
        </div>`;

        document.body.insertAdjacentHTML("beforeend", difficultyHTML);
      }

      // Function để chọn mode LẦN ĐẦU (không reset game đã có)
      function selectDifficulty(difficulty) {
        currentDifficulty = difficulty;
        const mode = DIFFICULTY_MODES[difficulty];

        console.log(`🎮 First time selecting difficulty: ${difficulty}`, mode);

        // Chỉ setup game state nếu chưa có game nào đang chạy
        if (!gameState || gameState.currentTurn === 1) {
          console.log(`📊 Setting up NEW game with stats:`, mode.startingStats);
          gameState = {
            currentTurn: 1,
            usedScenarios: [],
            stats: { ...mode.startingStats },
            score: 0,
          };
        } else {
          // Nếu đang có game, CHỈ cập nhật difficulty settings
          console.log(`🔄 Game đang chạy, chỉ cập nhật difficulty settings`);
        }

        maxTurns = mode.maxTurns;

        // Remove difficulty selection screen
        const difficultyModal = document.getElementById("difficultySelection");
        if (difficultyModal) {
          difficultyModal.remove();
        }

        // Remove existing difficulty indicator if any
        const existingIndicator = document.getElementById("difficulty-indicator");
        if (existingIndicator) {
          existingIndicator.remove();
        }

        // Show difficulty indicator nếu chưa có
        if (!document.getElementById("difficulty-indicator")) {
          showDifficultyIndicator(mode.name);
        }

        console.log(`✅ Difficulty selected (no reset):`, gameState?.stats || "No game state yet");

        // ✨ CẬP NHẬT UI (nếu có gameState)
        if (gameState) {
          updateDisplay();
        }

        // Start game
        startGame();
      }

      // Function to show difficulty indicator
      function showDifficultyIndicator(difficultyName) {
        const indicator = `
        <div id="difficulty-indicator">
          🎮 ${difficultyName}
        </div>`;

        document.body.insertAdjacentHTML("beforeend", indicator);
      }

      // Function to apply difficulty modifiers to effects
      function applyDifficultyModifiers(effects) {
        const mode = DIFFICULTY_MODES[currentDifficulty];
        const modifiedEffects = {};

        Object.entries(effects).forEach(([stat, value]) => {
          if (value > 0) {
            // Positive effect - apply positive boost
            modifiedEffects[stat] = Math.round(value * mode.positiveBoost);
          } else {
            // Negative effect - apply effect multiplier
            modifiedEffects[stat] = Math.round(value * mode.effectMultiplier);
          }
        });

        return modifiedEffects;
      }

      // Generate story using Gemini AI
      async function generateAIStory() {
        try {
          // Prepare context from game state
          const context = {
            turn: gameState.currentTurn,
            stats: gameState.stats,
            history: gameState.eventHistory?.slice(-5) || [],
            difficulty: currentDifficulty,
          };

          // Prompt tiếng Việt cho tạo câu chuyện
          const storyPrompt = `
Bạn là một nhà thiết kế kịch bản game chuyên nghiệp. Hãy tạo một sự kiện câu chuyện hấp dẫn cho game chiến lược/mô phỏng.

BỐI CẢNH GAME:
- Lượt hiện tại: ${context.turn}
- Chỉ số người chơi: ${JSON.stringify(context.stats)}
- Các sự kiện gần đây: ${JSON.stringify(context.history)}
- Mức độ khó: ${context.difficulty}

YÊU CẦU:
1. Viết một sự kiện câu chuyện hấp dẫn (150-250 từ):
   - Phản ánh tình trạng game hiện tại và tiến độ người chơi
   - Đưa ra hậu quả có ý nghĩa dựa trên chỉ số người chơi
   - Phù hợp với mức độ khó ${context.difficulty}
   - Tạo ra căng thẳng và sự tham gia

2. Câu chuyện nên:
   - Có câu mở đầu kịch tính
   - Bao gồm chi tiết cụ thể liên quan đến tình huống hiện tại của người chơi
   - Trình bày tình huống thử thách có thể ảnh hưởng đến gameplay tương lai
   - Kết thúc bằng một tình huống hồi hộp hoặc thời điểm quyết định quan trọng

3. Giọng điệu và phong cách:
   - Viết ở ngôi thứ hai ("Bạn phát hiện...", "Quốc gia của bạn đối mặt...")
   - Sử dụng ngôn ngữ sinh động, đắm chìm
   - Cân bằng giữa yếu tố kịch tính và chiến lược
   - Duy trì tính nhất quán với các sự kiện trước đó

4. Xem xét các yếu tố này:
   - Nếu chỉ số cao: Đưa ra cơ hội tham vọng hoặc mối đe dọa lớn hơn
   - Nếu chỉ số thấp: Tập trung vào kịch bản sinh tồn hoặc phục hồi
   - Nếu số lượt cao: Làm leo thang các xung đột hiện có
   - Nếu số lượt thấp: Giới thiệu những bí ẩn mới hoặc nền tảng

ĐỊNH DẠNG MẪU:
"Khi bình minh ló dạng trên lãnh thổ của bạn, một sứ giả đến với tin tức khẩn cấp sẽ thử thách mọi thứ bạn đã xây dựng. [Tiếp tục với câu chuyện kết hợp các chỉ số và tạo ra những lựa chọn có ý nghĩa...]"

Hãy tạo sự kiện câu chuyện bằng tiếng Việt ngay bây giờ:`;

          const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: storyPrompt,
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.9, // Tính sáng tạo cao
                topK: 40, // Lựa chọn từ đa dạng
                topP: 0.95, // Sáng tạo nhưng tập trung
                maxOutputTokens: 400, // Giới hạn độ dài phản hồi (tăng cho tiếng Việt)
              },
            }),
          });

          if (!response.ok) {
            const errorData = await response.json();
            console.error("API Error:", errorData);
            throw new Error(`AI API call failed: ${response.status}`);
          }

          const data = await response.json();
          const generatedStory = {
            title: "🎭 Sự kiện đặc biệt",
            description: data.candidates[0].content.parts[0].text,
            turn: gameState.currentTurn,
            timestamp: new Date().toISOString(),
          };

          aiGeneratedStoryCache.push(generatedStory);

          // Display the AI generated story
          showAIStoryEvent(generatedStory);
        } catch (error) {
          console.error("Failed to generate AI story:", error);

          // Câu chuyện dự phòng nếu API lỗi
          const fallbackStory = {
            title: "⚡ Sự kiện bất ngờ",
            description: `Một tin tức bất ngờ đến từ vương quốc láng giềng trong lúc bạn đang ở lượt ${gameState.currentTurn}. Tình hình hiện tại đòi hỏi bạn phải đưa ra quyết định quan trọng dựa trên khả năng và tài nguyên hiện có. Điều này có thể thay đổi hoàn toàn tiến trình phát triển của đế chế bạn...`,
            turn: gameState.currentTurn,
            timestamp: new Date().toISOString(),
          };
          showAIStoryEvent(fallbackStory);
        }
      }

      // Display AI generated story event
      function showAIStoryEvent(story) {
        const eventDiv = document.createElement("div");
        eventDiv.className = "ai-story-event";

        // Parse story để tách phần lựa chọn nếu có
        const storyText = story.description;
        const hasChoices = storyText.includes("**Lựa chọn:**");
        let mainStory = storyText;
        let choices = "";

        if (hasChoices) {
          const parts = storyText.split("**Lựa chọn:**");
          mainStory = parts[0].trim();
          choices = parts[1].trim();
        }

        eventDiv.innerHTML = `
    <div class="ai-story-modal">
      <div class="modal-header">
        <div class="header-icon">🎭</div>
        <h3>Biên niên sử - Lượt ${story.turn}</h3>
        <div class="turn-badge">Turn ${story.turn}</div>
      </div>
      
      <div class="story-content">
        <div class="story-text">
          ${mainStory.replace(/\n/g, "<br>")}
        </div>
        
        ${
          choices
            ? `
          <div class="choices-section">
            <h4>🎯 Lựa chọn của bạn:</h4>
            <div class="choices-content">
              ${choices
                .replace(/\n/g, "<br>")
                .replace(/(\d+\.\s\*\*[^*]+\*\*)/g, '<div class="choice-option">$1</div>')}
            </div>
          </div>
        `
            : ""
        }
      </div>
      
      <div class="modal-footer">
        <button class="btn-primary" onclick="this.closest('.ai-story-event').remove()">
          ⚔️ Tiếp tục hành trình
        </button>
        <button class="btn-secondary" onclick="this.closest('.ai-story-event').remove()">
          📖 Ghi nhận
        </button>
      </div>
    </div>
  `;

        // ✅ Chỉnh màu sắc đồng nhất với theme chính của game
        const styles = document.createElement("style");
        styles.textContent = `
    .ai-story-event {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .ai-story-modal {
      background: linear-gradient(135deg, var(--background-light) 0%, var(--background-secondary) 100%);
      border: 2px solid var(--primary-color);
      border-radius: 20px;
      max-width: 700px;
      max-height: 80vh;
      overflow-y: auto;
      color: var(--text-primary);
      box-shadow: 
        0 25px 60px rgba(0, 0, 0, 0.6),
        0 0 40px var(--shadow-color),
        inset 0 0 20px rgba(99, 102, 241, 0.1);
      position: relative;
      animation: slideIn 0.4s ease;
    }

    @keyframes slideIn {
      from { transform: translateY(-50px) scale(0.9); }
      to { transform: translateY(0) scale(1); }
    }

    .modal-header {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      padding: 1.5rem;
      border-radius: 18px 18px 0 0;
      display: flex;
      align-items: center;
      gap: 1rem;
      position: relative;
      border-bottom: 2px solid var(--accent-color);
    }

    .header-icon {
      font-size: 2rem;
      filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
      color: white;
    }

    .modal-header h3 {
      color: white;
      margin: 0;
      font-size: 1.5rem;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      flex: 1;
      font-family: 'Poppins', sans-serif;
    }

    .turn-badge {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.8rem;
      color: white;
      backdrop-filter: blur(10px);
    }

    .story-content {
      padding: 2rem;
      line-height: 1.7;
    }

    .story-text {
      font-size: 1rem;
      margin-bottom: 1.5rem;
      text-align: justify;
      color: var(--text-secondary);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%);
      padding: 1.5rem;
      border-radius: 12px;
      border-left: 4px solid var(--primary-color);
      backdrop-filter: blur(10px);
    }

    .choices-section {
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 2px solid var(--border-color);
    }

    .choices-section h4 {
      color: var(--primary-color);
      margin-bottom: 1rem;
      font-size: 1.2rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      text-align: center;
    }

    .choices-content {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      padding: 1rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      backdrop-filter: blur(10px);
    }

    .choice-option {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
      margin: 0.5rem 0;
      padding: 0.8rem;
      border-radius: 8px;
      border-left: 3px solid var(--accent-color);
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .choice-option:hover {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
      transform: translateX(5px);
      border-color: var(--primary-color);
      box-shadow: 0 4px 15px var(--shadow-color);
    }

    .modal-footer {
      background: linear-gradient(135deg, var(--background-secondary), var(--background-dark));
      padding: 1.5rem;
      border-radius: 0 0 18px 18px;
      display: flex;
      gap: 1rem;
      justify-content: center;
      border-top: 2px solid var(--border-color);
    }

    .btn-primary, .btn-secondary {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 12px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
      font-family: 'Poppins', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      box-shadow: 0 4px 15px var(--shadow-color);
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      transform: translateY(-2px);
      box-shadow: 0 8px 25px var(--shadow-color);
    }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-color), var(--success-color));
      color: white;
      box-shadow: 0 4px 15px rgba(6, 214, 160, 0.3);
    }

    .btn-secondary:hover {
      background: linear-gradient(135deg, var(--success-color), var(--accent-color));
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(6, 214, 160, 0.4);
    }

    /* Scrollbar styling */
    .ai-story-modal::-webkit-scrollbar {
      width: 8px;
    }

    .ai-story-modal::-webkit-scrollbar-track {
      background: rgba(99, 102, 241, 0.1);
      border-radius: 10px;
    }

    .ai-story-modal::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 10px;
    }

    .ai-story-modal::-webkit-scrollbar-thumb:hover {
      background: var(--secondary-color);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .ai-story-modal {
        max-width: 90%;
        margin: 1rem;
      }
      
      .modal-header {
        padding: 1rem;
      }
      
      .story-content {
        padding: 1.5rem;
      }
      
      .modal-footer {
        flex-direction: column;
      }
    }

    /* Glow effects */
    .modal-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
      animation: headerGlow 3s ease-in-out infinite;
    }

    @keyframes headerGlow {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
  `;

        document.head.appendChild(styles);
        document.body.appendChild(eventDiv);
      }

      // Load game data
      async function loadGameData() {
        console.log("Starting to load game data...");

        // Load story data, events with choices, and endings
        console.log("Loading game data...");
        const [storyResponse, eventsWithChoicesResponse, endingsResponse] = await Promise.all([
          fetch("./game_story_data_expanded.json"),
          fetch("./random_events_with_choices.json"),
          fetch("./endings.json"),
        ]);

        console.log("Response status:", {
          story: storyResponse.status,
          eventsWithChoices: eventsWithChoicesResponse.status,
          endings: endingsResponse.status,
        });

        if (storyResponse.ok && eventsWithChoicesResponse.ok && endingsResponse.ok) {
          gameStoryData = await storyResponse.json();
          randomEventsWithChoicesData = await eventsWithChoicesResponse.json();
          const endingsJson = await endingsResponse.json();
          endingsData = endingsJson.endings || endingsJson;

          console.log("✅ Game data loaded successfully:", {
            scenarios: gameStoryData.length,
            randomEventsWithChoices: randomEventsWithChoicesData.length,
            endings: endingsData.length,
          });
          updateScenarioCounter();
          return; // Success, exit function
        } else {
          throw new Error(
            `HTTP Error: ${storyResponse.status}, ${eventsWithChoicesResponse.status}, ${endingsResponse.status}`
          );
        }
      }

      // Preload next stories for better performance
      function preloadNextStories() {
        if (gameState.currentTurn < maxTurns - 2) {
          const nextTurns = [gameState.currentTurn + 1, gameState.currentTurn + 2];

          nextTurns.forEach((turn) => {
            const cacheKey = `turn_${turn}_${gameState.usedScenarios.length}`;
            if (!storyCache.has(cacheKey) && gameStoryData.length > 0) {
              const usedSet = new Set(gameState.usedScenarios);
              const availableStories = gameStoryData.filter((story) => !usedSet.has(story.id));

              if (availableStories.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableStories.length);
                const story = availableStories[randomIndex];
                storyCache.set(cacheKey, story);
              }
            }
          });
        }
      }

      // Handle keyboard inputs
      function handleKeyPress(e) {
        if (gameState.gameEnded) return;

        // Space or Enter to continue/select first choice
        if ((e.code === "Space" || e.code === "Enter") && !isProcessingChoice) {
          const firstChoice = document.querySelector(".choice:not(.disabled)");
          if (firstChoice) {
            const choiceData = JSON.parse(firstChoice.dataset.choice);
            const index = parseInt(firstChoice.dataset.choiceIndex);
            makeChoice(choiceData, index);
          }
        }

        // Number keys 1-9 to select choices
        if (e.code.startsWith("Digit") && !isProcessingChoice) {
          const num = parseInt(e.code.replace("Digit", "")) - 1;
          const choices = document.querySelectorAll(".choice:not(.disabled)");
          if (choices[num]) {
            const choiceData = JSON.parse(choices[num].dataset.choice);
            const index = parseInt(choices[num].dataset.choiceIndex);
            makeChoice(choiceData, index);
          }
        }
      }

      // Update scenario counter display
      function updateScenarioCounter() {
        const counter = document.getElementById("scenarioCount");
        if (counter) {
          counter.textContent = gameStoryData.length;

          // Change color based on data completeness
          const scenarioCounterEl = counter.parentElement;
          if (gameStoryData.length >= 20) {
            scenarioCounterEl.style.color = "#4CAF50"; // Green for complete
          } else if (gameStoryData.length >= 10) {
            scenarioCounterEl.style.color = "#FF9800"; // Orange for partial
          } else {
            scenarioCounterEl.style.color = "#F44336"; // Red for minimal
          }
        }
      }

      // Reload game data function
      async function reloadGameData() {
        const btn = document.getElementById("reloadDataBtn");
        const originalText = btn.innerHTML;
        btn.innerHTML = "⏳ Đang tải...";
        btn.disabled = true;

        try {
          await loadGameData();
          // Show success message
          btn.innerHTML = "✅ Đã tải!";
          console.log("Game data reloaded successfully!");

          // Show notification to user
          const notification = document.createElement("div");
          notification.style.cssText = `
            position: fixed; top: 20px; right: 20px; 
            background: #4CAF50; color: white; 
            padding: 12px 20px; border-radius: 6px; 
            z-index: 1000; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
          `;
          notification.textContent = `✅ Đã tải ${gameStoryData.length} tình huống game!`;
          document.body.appendChild(notification);

          setTimeout(() => {
            notification.remove();
          }, 3000);
        } catch (error) {
          btn.innerHTML = "❌ Lỗi!";
          console.error("Failed to reload game data:", error);
        }

        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.disabled = false;
        }, 2000);
      }

      // Initialize game
      function startGame() {
        console.log("🎮 Starting game...");

        // Chỉ setup gameState nếu chưa có hoặc chưa được setup từ difficulty selection
        if (!gameState || !gameState.stats.hasOwnProperty("economy")) {
          console.log("⚠️ No valid gameState found, creating default...");
          gameState = {
            currentTurn: 1,
            usedScenarios: [],
            stats: {
              discontent: 50,
              conflict: 50,
              economy: 50,
              environment: 50,
              freedom: 50,
              security: 50,
            },
            score: 0,
          };
        } else {
          console.log("✅ Using existing gameState from difficulty selection:", gameState);
        }

        console.log("🎯 Current game stats:", gameState.stats);

        // Remove document event listeners first to prevent memory leaks
        window.removeEventListener("keydown", handleKeyPress);

        loadGameData()
          .then(() => {
            console.log("📚 Game data loaded, starting UI...");

            // Ẩn start screen và hiển thị game
            document.getElementById("startScreen").classList.add("hidden");
            document.getElementById("gameContainer").style.display = "block";
            document.getElementById("guideBtn").style.display = "block";

            console.log("🎯 Updating display with stats:", gameState.stats);
            updateDisplay();
            console.log("🔄 Loading first story...");
            loadCurrentStory();
          })
          .catch((error) => {
            console.error("❌ Error starting game:", error);
            alert("Lỗi khởi động game: " + error.message);
          });
      }

      // Update stats display with visual effects
      function updateStatsDisplay() {
        const statsPanel = document.getElementById("statsPanel");
        if (!statsPanel) return;

        Object.entries(gameState.stats).forEach(([stat, value]) => {
          // Check if stat element already exists
          let statElement = document.getElementById(`stat-${stat}`);
          const isNewElement = !statElement;

          if (isNewElement) {
            statElement = document.createElement("div");
            statElement.className = "stat";
            statElement.id = `stat-${stat}`;
            statsPanel.appendChild(statElement);
          }

          // Detect value changes for animation
          const oldValue = parseInt(statElement.dataset.oldValue) || value;
          const hasChanged = oldValue !== value;

          // Determine status class
          let statusClass = "";
          if (stat === "discontent" || stat === "conflict") {
            // Higher is worse for these stats
            if (value >= 70) statusClass = "critical";
            else if (value >= 50) statusClass = "warning";
            else statusClass = "good";
          } else {
            // Higher is better for these stats
            if (value <= 20) statusClass = "critical";
            else if (value <= 40) statusClass = "warning";
            else if (value >= 70) statusClass = "good";
          }

          // Color coding based on stat type and value
          let fillColor = "#4caf50"; // Default green
          if (stat === "discontent" || stat === "conflict") {
            fillColor = value >= 70 ? "#ff4444" : value >= 50 ? "#ffaa00" : "#4caf50";
          } else {
            fillColor = value >= 60 ? "#4caf50" : value >= 40 ? "#ffaa00" : "#ff4444";
          }

          // Update classes
          statElement.className = `stat ${statusClass}`;

          // Create change indicator if value changed
          let changeIndicator = "";
          if (hasChanged && !isNewElement) {
            const change = value - oldValue;
            const changeClass = change > 0 ? "" : "negative";
            changeIndicator = `<div class="stat-change ${changeClass}">${change > 0 ? "+" + change : change}</div>`;
          }

          statElement.innerHTML = `
            <div class="stat-label">${statLabels[stat]}</div>
            <div class="stat-value ${hasChanged ? "changed" : ""} ${
            value > oldValue ? "increased" : value < oldValue ? "decreased" : ""
          }" 
                 id="stat-value-${stat}" style="color: ${fillColor}">${value}</div>
            <div class="stat-bar">
              <div class="stat-fill" style="width: ${Math.max(
                0,
                Math.min(100, value)
              )}%; background: ${fillColor}"></div>
            </div>
            ${changeIndicator}
          `;

          // Store current value for next comparison
          statElement.dataset.oldValue = value;

          // Remove animation classes after animation completes
          if (hasChanged) {
            setTimeout(() => {
              const valueEl = document.getElementById(`stat-value-${stat}`);
              if (valueEl) {
                valueEl.classList.remove("changed", "increased", "decreased");
              }
              const changeEl = statElement.querySelector(".stat-change");
              if (changeEl) changeEl.remove();
            }, 2000);
          }
        });

        // Check for crisis situations
        checkCrisisSituations();
      }

      // Check and display crisis alerts
      function checkCrisisSituations() {
        const criticalStats = [];

        Object.entries(gameState.stats).forEach(([stat, value]) => {
          if (stat === "discontent" || stat === "conflict") {
            if (value >= 85) criticalStats.push(statLabels[stat]);
          } else {
            if (value <= 15) criticalStats.push(statLabels[stat]);
          }
        });

        if (criticalStats.length > 0) {
          const message = `KHỦNG HOẢNG: ${criticalStats.join(", ")} đang ở mức nguy hiểm!`;
          showCrisisAlert(message);
        }

        // Check for multiple problematic stats
        const problematicStats = Object.entries(gameState.stats).filter(([stat, value]) => {
          if (stat === "discontent" || stat === "conflict") {
            return value >= 70;
          } else {
            return value <= 30;
          }
        });

        if (problematicStats.length >= 3) {
          showCrisisAlert("CẢNH BÁO: Nhiều chỉ số đang ở mức có vấn đề!");
        }
      }

      // Show crisis alert
      function showCrisisAlert(message) {
        // Remove existing alert if any
        const existingAlert = document.querySelector(".crisis-alert");
        if (existingAlert) existingAlert.remove();

        const alertDiv = document.createElement("div");
        alertDiv.className = "crisis-alert";
        alertDiv.textContent = "⚠️ " + message;
        alertDiv.style.display = "block";

        document.body.appendChild(alertDiv);

        setTimeout(() => {
          if (alertDiv.parentNode) {
            alertDiv.remove();
          }
        }, 4000);
      }

      // Update turn and score with late game warning
      function updateGameInfo() {
        const turnElement = document.getElementById("turnCounter");
        const scoreElement = document.getElementById("gameScore");

        if (turnElement) {
          turnElement.textContent = gameState.currentTurn + "/" + maxTurns;

          // Add late game warning
          const gameProgress = gameState.currentTurn / maxTurns;
          if (gameProgress >= 0.75) {
            turnElement.classList.add("late-game");
          } else {
            turnElement.classList.remove("late-game");
          }
        }

        if (scoreElement) {
          scoreElement.textContent = gameState.score;
        }
      }

      // OPTIMIZED: Load current story function with caching and performance improvements
      let storyCache = new Map();
      let isLoadingStory = false;

      function loadCurrentStory() {
        // Prevent multiple simultaneous loads
        if (isLoadingStory) return;
        isLoadingStory = true;

        // Show loading state
        const storySection = document.querySelector(".story-section");
        storySection?.classList.add("loading");

        // Use requestAnimationFrame for smooth UI updates
        requestAnimationFrame(() => {
          console.log(`⚡ Loading story for turn ${gameState.currentTurn}/${maxTurns}`);

          // Check cache first
          const cacheKey = `turn_${gameState.currentTurn}_${gameState.usedScenarios.length}`;
          let storyData = storyCache.get(cacheKey);

          if (!storyData) {
            // Get available scenarios that haven't been used (optimized with Set)
            const usedSet = new Set(gameState.usedScenarios);
            const availableScenarios = gameStoryData.filter((scenario) => !usedSet.has(scenario.id));

            if (availableScenarios.length > 0) {
              // Use a random available scenario
              const randomIndex = Math.floor(Math.random() * availableScenarios.length);
              storyData = availableScenarios[randomIndex];
              gameState.usedScenarios.push(storyData.id);
              console.log(`✅ Selected scenario: ${storyData.title} (ID: ${storyData.id})`);
            } else {
              // All scenarios used, reset and start over
              if (gameStoryData.length > 0) {
                console.log("🔄 All scenarios used, resetting used scenarios list");
                gameState.usedScenarios = [];
                storyData = gameStoryData[Math.floor(Math.random() * gameStoryData.length)];
                gameState.usedScenarios.push(storyData.id);
              } else {
                // Fallback scenario
                storyData = {
                  id: 999,
                  title: "Quyết Định Quan Trọng",
                  description:
                    "Một tình huống quan trọng đang chờ quyết định của bạn. Hãy cân nhắc kỹ lưỡng trước khi hành động.",
                  choices: [
                    {
                      title: "Lựa chọn thận trọng",
                      text: "Hành động một cách cẩn thận và thận trọng để tránh rủi ro",
                      effects: { discontent: -5, security: 5, conflict: -3 },
                    },
                    {
                      title: "Hành động mạnh mẽ",
                      text: "Đưa ra quyết định quyết đoán và mạnh mẽ để giải quyết vấn đề",
                      effects: { conflict: -5, freedom: -5, security: 10 },
                    },
                  ],
                };
              }
            }

            // Cache the story for potential reuse
            storyCache.set(cacheKey, storyData);
          }

          // Display the story with smooth animation
          const titleEl = document.getElementById("storyTitle");
          const textEl = document.getElementById("storyText");

          if (titleEl) titleEl.textContent = storyData.title;
          if (textEl) textEl.textContent = storyData.description;

          displayChoices(storyData.choices);

          // Remove loading state
          setTimeout(() => {
            storySection?.classList.remove("loading");
            isLoadingStory = false;

            // Preload next stories for better performance
            preloadNextStories();
          }, 100);
        });
      }

      // OPTIMIZED: Display choices with highlighting for high impact
      function displayChoices(choices) {
        const choicesGrid = document.getElementById("choicesGrid");
        if (!choicesGrid) return;

        // Ensure we have at least 1 choice
        if (!choices || choices.length === 0) {
          choices = [
            {
              title: "Tiếp tục",
              text: "Chuyển sang lượt tiếp theo",
              effects: { discontent: 0 },
            },
          ];
        }

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();

        choices.forEach((choice, index) => {
          const choiceElement = document.createElement("div");
          let choiceClass = "choice";

          // Check if this is a high impact choice
          const isHighImpact = checkHighImpact(choice.effects);
          if (isHighImpact) {
            choiceClass += " high-impact";
          }

          choiceElement.className = choiceClass;

          // Use event delegation instead of individual onclick handlers
          choiceElement.dataset.choiceIndex = index;
          choiceElement.dataset.choice = JSON.stringify(choice);

          // Create effects preview with enhanced formatting
          let effectsPreview = "";
          if (choice.effects) {
            Object.entries(choice.effects).forEach(([stat, change]) => {
              if (change !== 0) {
                const sign = change > 0 ? "+" : "";
                const statName = statLabels[stat] || stat;
                const impactClass = Math.abs(change) >= 15 ? " high-impact-effect" : "";
                effectsPreview += `<span class="effect-item${impactClass}">${statName} ${sign}${change}</span> `;
              }
            });
          }

          choiceElement.innerHTML = `
            <div class="choice-title">${choice.title}</div>
            <div class="choice-text">${choice.text}</div>
            <div class="choice-effects">Tác động: ${effectsPreview || "Không có"}</div>
          `;

          fragment.appendChild(choiceElement);
        });

        // Clear and append all choices at once for better performance
        choicesGrid.innerHTML = "";
        choicesGrid.appendChild(fragment);

        // Add event delegation listener if not already added
        if (!choicesGrid.hasAttribute("data-listener-added")) {
          choicesGrid.addEventListener("click", function (e) {
            const choiceEl = e.target.closest(".choice");
            if (choiceEl && !choiceEl.classList.contains("disabled")) {
              const choice = JSON.parse(choiceEl.dataset.choice);
              const index = parseInt(choiceEl.dataset.choiceIndex);
              makeChoice(choice, index);
            }
          });
          choicesGrid.setAttribute("data-listener-added", "true");
        }
      }

      // Check if a choice has high impact effects
      function checkHighImpact(effects) {
        if (!effects) return false;

        // Consider high impact if any effect is >= 15 or <= -15
        return Object.values(effects).some((value) => Math.abs(value) >= 15);
      }

      // OPTIMIZED: Make choice with debouncing and faster processing
      let isProcessingChoice = false;

      function makeChoice(choice, index) {
        // Prevent double-clicking with debouncing
        if (isProcessingChoice) return;
        isProcessingChoice = true;

        console.log(`⚡ Making choice at turn ${gameState.currentTurn}:`, choice.title);

        // Check for emergency endings (negative conditions)
        const emergencyEndingConditions = {
          discontent: gameState.stats.discontent >= 90,
          conflict: gameState.stats.conflict >= 90,
          economy: gameState.stats.economy <= 10,
        };

        const shouldTriggerEmergencyEnding = Object.values(emergencyEndingConditions).some((condition) => condition);

        // Only check for endings if it's the last turn or emergency conditions are met
        const isLastTurn = gameState.currentTurn >= maxTurns;
        if (shouldTriggerEmergencyEnding || isLastTurn) {
          const endingToShow = findAppropriateEnding();
          if (endingToShow) {
            gameState.gameEnded = true;
            showEnding(endingToShow);
            return;
          }
        }

        // Continue with normal turn if no ending triggered

        // Check if it's time to generate AI story (every 5 turns)
        if (gameState.currentTurn % 5 === 0) {
          console.log("start story");
          generateAIStory();
        }

        // Disable all choices immediately to prevent double-clicks
        const allChoices = document.querySelectorAll(".choice");
        allChoices.forEach((el) => {
          el.classList.add("disabled");
        });

        // Use requestAnimationFrame for smooth processing
        requestAnimationFrame(() => {
          // Apply difficulty modifiers
          const modifiedEffects = applyDifficultyModifiers(choice.effects || {});
          console.log("Modified effects:", modifiedEffects);

          // Apply effects with optimized loop
          let totalChange = 0;
          for (const [stat, change] of Object.entries(modifiedEffects)) {
            if (gameState.stats.hasOwnProperty(stat)) {
              const oldValue = gameState.stats[stat];
              gameState.stats[stat] = Math.max(0, Math.min(100, gameState.stats[stat] + change));
              console.log(`📈 ${stat}: ${oldValue} -> ${gameState.stats[stat]} (${change > 0 ? "+" : ""}${change})`);
              totalChange += Math.abs(change);
            }
          }

          // Update score
          gameState.score += totalChange;
          console.log(`🎯 Score updated: +${totalChange}, Total: ${gameState.score}`);

          // Update display immediately to show changes
          updateDisplay();
          console.log("🔄 Display updated with new stats");

          // Check for game end conditions
          if (checkGameEnd()) {
            isProcessingChoice = false;
            return;
          }

          // Next turn
          gameState.currentTurn++;

          // Random event chance based on difficulty with cooldown
          const mode = DIFFICULTY_MODES[currentDifficulty];
          const eventChance = Math.random();
          const turnsSinceLastEvent = gameState.currentTurn - lastEventTurn;

          console.log(
            `🎲 Event check: roll=${eventChance.toFixed(2)} vs ${
              mode.randomEventsFrequency
            }, cooldown=${turnsSinceLastEvent}/${eventCooldown}`
          );

          setTimeout(() => {
            // Only trigger if conditions met: min turn, cooldown passed AND chance hits
            const canTriggerEvent = turnsSinceLastEvent >= eventCooldown && gameState.currentTurn >= minEventTurn;
            const shouldTriggerEvent = eventChance < mode.randomEventsFrequency;

            if (canTriggerEvent && shouldTriggerEvent && randomEventsWithChoicesData.length > 0) {
              console.log("🎪 Triggering random event!");
              lastEventTurn = gameState.currentTurn;
              triggerRandomEvent();
              setTimeout(() => {
                loadCurrentStory();
                isProcessingChoice = false;
              }, 3000);
            } else {
              console.log(`📖 No event: cooldown=${canTriggerEvent}, chance=${shouldTriggerEvent}`);
              loadCurrentStory();
              isProcessingChoice = false;
            }
          }, 800);
        });
      }

      // Trigger random event - now supports both types of events
      function triggerRandomEvent() {
        console.log("🎪 triggerRandomEvent called...");

        const event = selectRandomEventWithChoices();
        if (event) {
          console.log(`🎲 Random event selected: ${event.title}`);
          showRandomEventWithChoices(event);
        } else {
          console.log("🚫 No random events available for current conditions");
        }
      }
      function checkEventConditions(event) {
        if (!event.conditions) return true;

        // Check min_turn
        if (event.conditions.min_turn && gameState.currentTurn < event.conditions.min_turn) {
          return false;
        }

        // Check mỗi stat condition
        for (let stat in event.conditions) {
          if (stat === "min_turn") continue;

          let condition = event.conditions[stat];
          let currentValue = gameState.stats[stat];

          // Check min condition
          if (condition.min && currentValue < condition.min) {
            return false;
          }

          // Check max condition
          if (condition.max && currentValue > condition.max) {
            return false;
          }
        }

        return true;
      }
      // Select random event with choices
      function selectRandomEventWithChoices() {
        console.log("🔍 Selecting random event with choices from", randomEventsWithChoicesData?.length || 0, "events");
        if (!randomEventsWithChoicesData || randomEventsWithChoicesData.length === 0) {
          console.log("❌ No random events with choices data available");
          return null;
        }

        // Filter events that meet conditions AND haven't been used recently
        const availableEvents = randomEventsWithChoicesData.filter((event) => {
          // Skip if event was used recently
          if (usedEvents.has(event.title)) {
            console.log(`⏭️ Skipping used event: ${event.title}`);
            return false;
          }

          // Check basic conditions
          const meetsConditions = checkEventConditions(event);
          console.log(`📋 Event with choices "${event.title}" meets conditions:`, meetsConditions);

          if (!meetsConditions) return false;

          // For conditional events, check trigger_chance
          if (event.rarity === "conditional") {
            const triggerRoll = Math.random() < event.trigger_chance;
            console.log(`🎲 Conditional event with choices roll: ${triggerRoll}`);
            return triggerRoll;
          }

          return true;
        });

        console.log("✅ Available events with choices after filtering:", availableEvents.length);
        if (availableEvents.length === 0) {
          console.log("⚠️ No events with choices available for current conditions");
          return null;
        }

        // Select random from available and mark as used
        const selectedEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
        usedEvents.add(selectedEvent.title);
        console.log("🎯 Selected event with choices:", selectedEvent.title, "| Used events:", usedEvents.size);
        return selectedEvent;
      }

      // Show random event in center screen
      function showRandomEvent(event) {
        if (!event) return;

        console.log(`🎪 Showing random event: ${event.title}`);

        // Apply effects with difficulty modifiers
        const modifiedEffects = applyDifficultyModifiers(event.effects || {});
        let totalChange = 0;

        // Apply effects to game state first
        Object.entries(modifiedEffects).forEach(([stat, change]) => {
          if (change !== 0) {
            const oldValue = gameState.stats[stat];
            gameState.stats[stat] = Math.max(0, Math.min(100, gameState.stats[stat] + change));
            totalChange += Math.abs(change);
            console.log(
              `Random event effect - ${stat}: ${oldValue} -> ${gameState.stats[stat]} (${
                change > 0 ? "+" : ""
              }${change})`
            );
          }
        });

        // Update score
        gameState.score += totalChange * 2; // Random events give bonus score

        // Create event popup in center screen
        const eventDiv = document.createElement("div");
        eventDiv.className = "random-event-popup";
        eventDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #1a1a2e, #16213e);
          color: white;
          padding: 35px;
          border-radius: 25px;
          border: 3px solid #f59e0b;
          max-width: 700px;
          z-index: 10000;
          box-shadow: 0 25px 60px rgba(0,0,0,0.8), 0 0 40px rgba(245, 158, 11, 0.3);
          animation: eventSlideIn 0.8s cubic-bezier(0.4, 0, 0.2, 1);
          backdrop-filter: blur(15px);
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
        `;

        // Determine event severity
        const isHighImpact = Object.values(modifiedEffects).some((val) => Math.abs(val) >= 15);
        const severityColor = isHighImpact ? "#ef4444" : "#f59e0b";
        const severityIcon = isHighImpact ? "💥" : "⚡";

        eventDiv.innerHTML = `
          <div style="text-align: center; margin-bottom: 25px;">
            <h2 style="color: ${severityColor}; margin-bottom: 10px; font-size: 1.8em; animation: eventTitleGlow 2s infinite;">
              ${severityIcon} RANDOM EVENT! ${severityIcon}
            </h2>
            <div style="background: rgba(245, 158, 11, 0.15); padding: 8px 16px; border-radius: 20px; display: inline-block; font-size: 0.9em; color: #f59e0b; border: 1px solid rgba(245, 158, 11, 0.3);">
              Lượt ${gameState.currentTurn} | ${event.rarity?.toUpperCase() || "RANDOM"}
            </div>
          </div>
          
          <h3 style="color: #f59e0b; margin-bottom: 20px; text-align: center; font-size: 1.6em; line-height: 1.2;">
            ${event.title}
          </h3>
          
          <p style="margin-bottom: 30px; line-height: 1.7; text-align: center; font-size: 1.15em; color: #e2e8f0; padding: 0 10px;">
            ${event.text}
          </p>
          
          <div style="background: rgba(99, 102, 241, 0.15); padding: 25px; border-radius: 15px; margin-bottom: 30px; border: 1px solid rgba(99, 102, 241, 0.3);">
            <h4 style="color: #6366f1; margin-bottom: 20px; text-align: center; font-size: 1.2em;">📊 Tác Động Lên Chỉ Số:</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
              ${Object.entries(modifiedEffects)
                .map(([stat, change]) => {
                  if (change === 0) return "";
                  return `<span style="
                  display: inline-block; 
                  padding: 10px 15px; 
                  background: ${change > 0 ? "rgba(239, 68, 68, 0.2)" : "rgba(16, 185, 129, 0.2)"}; 
                  border: 2px solid ${change > 0 ? "#ef4444" : "#10b981"};
                  border-radius: 25px; 
                  color: ${change > 0 ? "#ef4444" : "#10b981"};
                  font-weight: 700;
                  font-size: 1em;
                  ${
                    Math.abs(change) >= 15
                      ? "animation: highImpactEffect 2s infinite; box-shadow: 0 0 15px rgba(255,255,255,0.2);"
                      : ""
                  }
                ">
                  ${statLabels[stat] || stat}: ${change > 0 ? "+" : ""}${change}
                </span>`;
                })
                .filter(Boolean)
                .join("")}
            </div>
          </div>
          
          <div style="text-align: center;">
            <button onclick="closeRandomEvent(this)" 
                    style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; padding: 18px 40px; border-radius: 30px; cursor: pointer; font-weight: 700; font-size: 1.2em; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px;">
              ⚡ Tiếp Tục Game
            </button>
          </div>
        `;

        // Add to body
        document.body.appendChild(eventDiv);

        // Update display
        updateDisplay();

        // Add close function
        window.closeRandomEvent = function (button) {
          const eventPopup = button.closest(".random-event-popup");
          eventPopup.style.animation = "eventSlideOut 0.5s ease-in";
          setTimeout(() => {
            if (eventPopup.parentNode) {
              eventPopup.remove();
            }
            delete window.closeRandomEvent;
          }, 500);
        };

        // Add hover effect to button
        const continueBtn = eventDiv.querySelector("button");
        continueBtn.addEventListener("mouseenter", function () {
          this.style.transform = "scale(1.05) translateY(-2px)";
          this.style.boxShadow = "0 10px 30px rgba(245, 158, 11, 0.5)";
        });
        continueBtn.addEventListener("mouseleave", function () {
          this.style.transform = "scale(1) translateY(0)";
          this.style.boxShadow = "none";
        });

        // Update stats display after applying effects
        updateStatsDisplay();

        // Auto-hide after 5 seconds
        setTimeout(() => {
          randomEventEl.style.display = "none";
        }, 5000);
      }

      // Show random event with choices
      function showRandomEventWithChoices(event) {
        if (!event) return;

        console.log(`🎪 Showing random event with choices: ${event.title}`);

        // Create event popup in center screen with choices
        const eventDiv = document.createElement("div");
        eventDiv.className = "random-event-popup";
        eventDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #1a1a2e, #16213e);
          color: white;
          padding: 35px;
          border-radius: 25px;
          border: 3px solid #f59e0b;
          max-width: 800px;
          z-index: 10000;
          box-shadow: 0 25px 60px rgba(0,0,0,0.8), 0 0 40px rgba(245, 158, 11, 0.3);
          animation: eventSlideIn 0.8s cubic-bezier(0.4, 0, 0.2, 1);
          backdrop-filter: blur(15px);
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
        `;

        // Determine event severity
        const isHighImpact = event.choices.some((choice) =>
          Object.values(choice.effects).some((val) => Math.abs(val) >= 15)
        );
        const severityColor = isHighImpact ? "#ef4444" : "#f59e0b";
        const severityIcon = isHighImpact ? "💥" : "⚡";

        eventDiv.innerHTML = `
          <div style="text-align: center; margin-bottom: 25px;">
            <h2 style="color: ${severityColor}; margin-bottom: 10px; font-size: 1.8em; animation: eventTitleGlow 2s infinite;">
              ${severityIcon} RANDOM EVENT WITH CHOICES! ${severityIcon}
            </h2>
            <div style="background: rgba(245, 158, 11, 0.15); padding: 8px 16px; border-radius: 20px; display: inline-block; font-size: 0.9em; color: #f59e0b; border: 1px solid rgba(245, 158, 11, 0.3);">
              Lượt ${gameState.currentTurn} | ${event.rarity?.toUpperCase() || "RANDOM"}
            </div>
          </div>
          
          <h3 style="color: #f59e0b; margin-bottom: 20px; text-align: center; font-size: 1.6em; line-height: 1.2;">
            ${event.title}
          </h3>
          
          <p style="margin-bottom: 30px; line-height: 1.7; text-align: center; font-size: 1.15em; color: #e2e8f0; padding: 0 10px;">
            ${event.text}
          </p>
          
          <div style="margin-bottom: 30px;">
            <h4 style="color: #6366f1; margin-bottom: 20px; text-align: center; font-size: 1.2em;">📋 Lựa Chọn Của Bạn:</h4>
            <div class="choices-container" style="display: flex; flex-direction: column; gap: 15px;">
              ${event.choices
                .map((choice, index) => {
                  const isHighImpactChoice = Object.values(choice.effects).some((val) => Math.abs(val) >= 15);
                  const choiceClass = isHighImpactChoice ? "high-impact-choice" : "";

                  let effectsPreview = "";
                  if (choice.effects) {
                    Object.entries(choice.effects).forEach(([stat, change]) => {
                      if (change !== 0) {
                        const sign = change > 0 ? "+" : "";
                        const statName = statLabels[stat] || stat;
                        const impactClass = Math.abs(change) >= 15 ? " high-impact-effect" : "";
                        effectsPreview += `<span class="effect-item${impactClass}">${statName} ${sign}${change}</span> `;
                      }
                    });
                  }

                  return `
                  <div class="choice-option ${choiceClass}" onclick="handleEventChoice(${event.id}, ${index})" 
                       style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%); 
                              padding: 20px; border-radius: 15px; border: 2px solid rgba(99, 102, 241, 0.3); 
                              cursor: pointer; transition: all 0.3s ease; ${
                                isHighImpactChoice
                                  ? "border-color: #ef4444; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);"
                                  : ""
                              }">
                    <div style="font-weight: 700; font-size: 1.1em; margin-bottom: 10px; color: ${
                      isHighImpactChoice ? "#ef4444" : "#f59e0b"
                    };">${choice.title}</div>
                    <div style="margin-bottom: 15px; color: #e2e8f0;">${choice.text}</div>
                    <div style="font-size: 0.9em; color: #cbd5e1;">Tác động: ${effectsPreview || "Không có"}</div>
                  </div>
                `;
                })
                .join("")}
            </div>
          </div>
        `;

        // Add to body
        document.body.appendChild(eventDiv);

        // Add hover effects to choices
        const choiceOptions = eventDiv.querySelectorAll(".choice-option");
        choiceOptions.forEach((option) => {
          option.addEventListener("mouseenter", function () {
            this.style.transform = "translateY(-3px) scale(1.02)";
            this.style.boxShadow = "0 8px 25px rgba(99, 102, 241, 0.3)";
          });
          option.addEventListener("mouseleave", function () {
            this.style.transform = "translateY(0) scale(1)";
            this.style.boxShadow = "none";
          });
        });

        // Add global function to handle choice selection
        window.handleEventChoice = function (eventId, choiceIndex) {
          const selectedEvent = randomEventsWithChoicesData.find((e) => e.id === eventId);
          if (!selectedEvent) return;

          const selectedChoice = selectedEvent.choices[choiceIndex];
          console.log(`🎯 Selected choice for event ${eventId}: ${selectedChoice.title}`);

          // Apply effects with difficulty modifiers
          const modifiedEffects = applyDifficultyModifiers(selectedChoice.effects || {});
          let totalChange = 0;

          // Apply effects to game state
          Object.entries(modifiedEffects).forEach(([stat, change]) => {
            if (change !== 0) {
              const oldValue = gameState.stats[stat];
              gameState.stats[stat] = Math.max(0, Math.min(100, gameState.stats[stat] + change));
              totalChange += Math.abs(change);
              console.log(
                `Event choice effect - ${stat}: ${oldValue} -> ${gameState.stats[stat]} (${
                  change > 0 ? "+" : ""
                }${change})`
              );
            }
          });

          // Update score
          gameState.score += totalChange * 2; // Events with choices give bonus score

          // Update display
          updateDisplay();

          // Remove event popup
          const eventPopup = document.querySelector(".random-event-popup");
          if (eventPopup) eventPopup.remove();

          // Clean up global function
          delete window.handleEventChoice;

          // Continue with next turn
          setTimeout(() => {
            loadCurrentStory();
          }, 1000);
        };
      }

      // Function để đánh giá ending theo requirements từ endings.json
      function evaluateEnding(ending) {
        if (!ending.requirements) return false;

        const stats = gameState.stats;
        const req = ending.requirements;

        console.log(`🎯 Evaluating ending: ${ending.id}`, {
          currentStats: stats,
          requirements: req,
        });

        // Check basic stat requirements
        for (const [statName, condition] of Object.entries(req)) {
          // Special cases first
          if (statName === "min_turn") {
            const minTurn = parseInt(condition.replace(/[≥\s]/g, ""));
            if (gameState.currentTurn < minTurn) {
              console.log(`❌ Failed min_turn: ${gameState.currentTurn} < ${minTurn}`);
              return false;
            }
            continue;
          }

          if (statName === "completed_turns") {
            if (condition === "= max_turns") {
              if (gameState.currentTurn <= maxTurns) {
                // Fixed: should be <= not <
                console.log(`❌ Failed completed_turns: ${gameState.currentTurn} <= ${maxTurns}`);
                return false;
              }
            }
            continue;
          }

          if (statName === "triggered_by") {
            // Check if the required ending has been triggered
            if (!triggeredEndings.has(condition)) {
              console.log(`❌ Failed triggered_by: ${condition} not triggered yet`);
              return false;
            }
            continue;
          }

          // Regular stat checks
          const currentValue = stats[statName];
          if (currentValue === undefined) {
            console.log(`❌ Stat not found: ${statName}`);
            return false; // Changed: return false instead of continue
          }

          // Parse condition more carefully
          let passed = false;
          const conditionStr = String(condition).trim();

          if (conditionStr.includes("≤")) {
            const threshold = parseInt(conditionStr.replace(/[≤\s]/g, ""));
            passed = currentValue <= threshold;
            console.log(`📊 ${statName}: ${currentValue} ≤ ${threshold} = ${passed}`);
          } else if (conditionStr.includes("≥")) {
            const threshold = parseInt(conditionStr.replace(/[≥\s]/g, ""));
            passed = currentValue >= threshold;
            console.log(`📊 ${statName}: ${currentValue} ≥ ${threshold} = ${passed}`);
          } else {
            // Fallback: try to parse as number for exact match
            const exactValue = parseInt(conditionStr);
            if (!isNaN(exactValue)) {
              passed = currentValue === exactValue;
              console.log(`📊 ${statName}: ${currentValue} === ${exactValue} = ${passed}`);
            } else {
              console.log(`❌ Unknown condition format: ${conditionStr}`);
              return false;
            }
          }

          if (!passed) {
            console.log(`❌ Failed requirement: ${statName} ${condition} (current: ${currentValue})`);
            return false;
          }
        }

        console.log(`✅ All requirements met for ending: ${ending.id}`);
        return true;
      }

      // Check game end conditions using endings.json
      function checkGameEnd() {
        console.log("🎯 Checking game end conditions...");
        console.log("📊 Current game state:", {
          turn: gameState.currentTurn,
          maxTurns: maxTurns,
          stats: gameState.stats,
          gameEnded: gameState.gameEnded,
        });

        if (gameState.gameEnded) {
          console.log("🔒 Game already ended, skipping checks");
          return true;
        }

        // 🚨 KIỂM TRA CÁC TRƯỜNG HỢP CỰC ĐOAN TRƯỚC (ưu tiên cao nhất)
        console.log("🚨 Checking critical failure conditions first...");

        // Cách mạng - Conflict quá cao
        if (gameState.stats.conflict >= 85) {
          console.log("💥 CRITICAL: Conflict >= 85, triggering revolution");
          endGame(
            "revolution",
            "🔥 CÁCH MẠNG BÙNG NỔ",
            "Xung đột xã hội vượt quá ngưỡng chịu đựng. Hàng triệu người xuống đường biểu tình. Chính phủ của bạn đã bị lật đổ bởi sức mạnh của nhân dân!"
          );
          return true;
        }

        // Sụp đổ kinh tế - Economy quá thấp
        if (gameState.stats.economy <= 10) {
          console.log("📉 CRITICAL: Economy <= 10, triggering economic collapse");
          endGame(
            "economic_collapse",
            "📉 SUY THOÁI KINH TẾ",
            "Nền kinh tế sụp đổ hoàn toàn. Đất nước rơi vào khủng hoảng tài chính nghiêm trọng. Thất nghiệp cao, lạm phát tăng vọt. Bạn đã thất bại trong việc lãnh đạo kinh tế!"
          );
          return true;
        }

        // Thảm họa môi trường - Environment quá thấp
        if (gameState.stats.environment <= 10) {
          console.log("🌍 CRITICAL: Environment <= 10, triggering environmental disaster");
          endGame(
            "environmental_disaster",
            "🌍 THẢM HỌA MÔI TRƯỜNG",
            "Môi trường bị tàn phá nghiêm trọng. Biến đổi khí hậu và ô nhiễm đã làm đất nước không thể sinh sống được. Thảm họa sinh thái đã xảy ra!"
          );
          return true;
        }

        // Mất quyền lực - Discontent quá cao
        if (gameState.stats.discontent >= 85) {
          console.log("🔻 CRITICAL: Discontent >= 85, triggering overthrow");
          endGame(
            "overthrown",
            "🔻 MẤT QUYỀN LỰC",
            "Sự bất mãn của dân chúng đạt đỉnh điểm. Người dân không còn tin tưởng vào chính quyền. Bạn bị truất phế khỏi chức vụ!"
          );
          return true;
        }

        // Security quá thấp - Mất kiểm soát
        if (gameState.stats.security <= 5) {
          console.log("⚠️ CRITICAL: Security <= 5, triggering anarchy");
          endGame(
            "anarchy",
            "⚡ TÌNH TRẠNG VÔ CHÍNH PHỦ",
            "An ninh sụp đổ hoàn toàn. Tội phạm hoành hành, luật pháp không còn hiệu lực. Đất nước rơi vào tình trạng hỗn loạn!"
          );
          return true;
        }

        // Freedom quá thấp + Security quá cao = Độc tài ngay lập tức
        if (gameState.stats.freedom <= 5 && gameState.stats.security >= 90) {
          console.log("⚔️ CRITICAL: Extreme dictatorship detected");
          endGame(
            "extreme_dictatorship",
            "👑 ĐỘC TÀI TUYỆT ĐỐI",
            "Bạn đã thiết lập chế độ độc tài tuyệt đối. Mọi quyền tự do bị triệt tiêu, kiểm soát tuyệt đối. Nhưng lịch sử chứng minh... không ai cai trị mãi mãi!"
          );
          return true;
        }

        // 📚 SAU ĐÓ MỚI KIỂM TRA ENDINGS.JSON (cho các trường hợp bình thường)
        // QUAN TRỌNG: Chỉ kiểm tra endings đặc biệt sau turn 3 để tránh ending sớm
        if (Array.isArray(endingsData) && endingsData.length > 0 && gameState.currentTurn >= 3) {
          console.log(`📚 Evaluating ${endingsData.length} endings from endings.json (turn ${gameState.currentTurn})`);

          // Evaluate each ending in order from most specific to generic
          for (const ending of endingsData) {
            if (triggeredEndings.has(ending.id)) continue; // Skip already shown endings

            // Filter out premature endings - some endings should only trigger after certain turns
            const earlyEndingIds = ["dictator_temporary", "authoritarian_stability", "talented_leader"];
            if (earlyEndingIds.includes(ending.id) && gameState.currentTurn < 5) {
              console.log(`⏰ Skipping early ending ${ending.id} (turn ${gameState.currentTurn} < 5)`);
              continue;
            }

            if (evaluateEnding(ending)) {
              // Handle leads_to chain for dictator path
              if (ending.leads_to) {
                console.log(`� Chain ending detected: ${ending.id} → ${ending.leads_to}`);

                // Trigger temporary ending first (if defined) then queue leads_to
                endGame(ending.id, ending.name, ending.description);
                triggeredEndings.add(ending.id);

                // If the ending leads to another ending (e.g. dictator -> hitler_aftermath)
                const nextEnding = endingsData.find((e) => e.id === ending.leads_to);
                if (nextEnding) {
                  // Show the follow-up ending after a short delay
                  setTimeout(() => {
                    console.log(`🔗 Triggering follow-up ending: ${nextEnding.id}`);
                    endGame(nextEnding.id, nextEnding.name, nextEnding.description);
                    triggeredEndings.add(nextEnding.id);
                  }, 2000);
                }
                return true;
              }

              // Normal ending
              console.log(`✅ Triggering ending: ${ending.id}`);
              endGame(ending.id, ending.name, ending.description);
              triggeredEndings.add(ending.id);
              return true;
            }
          }
        }

        // Fallback: Basic failure conditions if no endings.json
        console.log("⚠️ Using fallback ending conditions");

        if (gameState.stats.conflict >= 85) {
          endGame("revolution", "🔥 CÁCH MẠNG BÙNG NỔ", "Xung đột đạt mức tới hạn!");
          return true;
        }

        if (gameState.stats.economy <= 10) {
          endGame("economic_collapse", "� SỤP ĐỔ KINH TẾ", "Nền kinh tế sụp đổ hoàn toàn!");
          return true;
        }

        if (gameState.stats.environment <= 10) {
          endGame("environmental_disaster", "� THẢM HỌA MÔI TRƯỜNG", "Môi trường bị tàn phá!");
          return true;
        }

        // Natural end at max turns
        if (gameState.currentTurn > maxTurns) {
          endGame("natural_end", "⏰ KẾT THÚC NHIỆM KỲ", `Hoàn thành nhiệm kỳ ${maxTurns} lượt.`);
          return true;
        }

        console.log("❌ No ending conditions met");
        return false;
      }

      // End game
      function endGame(endingType, title, description) {
        console.log(`Game ended with: ${endingType}`);
        gameState.gameEnded = true;
        document.getElementById("endingTitle").textContent = title;
        document.getElementById("endingDescription").textContent = description;
        document.getElementById("gameEnd").style.display = "block";
        document.getElementById("choicesGrid").style.display = "none";
      }

      // Restart game
      function restartGame() {
        console.log("Restarting game...");

        // Reset game state
        gameState = {
          currentTurn: 1,
          stats: {
            discontent: 45,
            conflict: 35,
            economy: 55,
            environment: 50,
            freedom: 60,
            security: 45,
          },
          score: 0,
          gameEnded: false,
          eventHistory: [],
          usedScenarios: [],
        };

        dictatorModeTriggered = false;
        triggeredEndings.clear(); // Reset triggered endings

        // Reset event tracking
        usedEvents.clear();
        lastEventTurn = 0;

        // Remove difficulty indicator
        const indicator = document.getElementById("difficulty-indicator");
        if (indicator) indicator.remove();

        // Hide end screen
        document.getElementById("gameEnd").style.display = "none";
        document.getElementById("choicesGrid").style.display = "grid";
        document.getElementById("guideBtn").style.display = "none";

        // Hide game container and show start screen
        document.getElementById("gameContainer").style.display = "none";
        document.getElementById("startScreen").classList.remove("hidden");
      }

      // Update all displays
      function updateDisplay() {
        updateStatsDisplay();
        updateGameInfo();
      }

      // Guide functions
      function openGuide() {
        document.getElementById("guideModal").style.display = "flex";
      }

      function closeGuide() {
        document.getElementById("guideModal").style.display = "none";
      }

      // Close guide when clicking outside
      document.getElementById("guideModal").addEventListener("click", function (e) {
        if (e.target === this) {
          closeGuide();
        }
      });

      // Initialize when page loads
      window.addEventListener("load", function () {
        console.log("Political Simulator loaded with difficulty modes and comprehensive guide");
        // Add keyboard event listener
        window.addEventListener("keydown", handleKeyPress);
      });
    </script>
  </body>
</html>
